/*
 * generated by Xtext 2.22.0
 */
package org.bumble.eastadl.simplified.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.bumble.eastadl.simplified.services.EastAdlSimplifiedGrammarAccess;
import org.eclipse.eatop.eastadl21.Actuator;
import org.eclipse.eatop.eastadl21.Allocation;
import org.eclipse.eatop.eastadl21.ArrayDatatype;
import org.eclipse.eatop.eastadl21.BasicSoftwareFunctionType;
import org.eclipse.eatop.eastadl21.Comment;
import org.eclipse.eatop.eastadl21.CommunicationHardwarePin;
import org.eclipse.eatop.eastadl21.CompositeDatatype;
import org.eclipse.eatop.eastadl21.DesignFunctionPrototype;
import org.eclipse.eatop.eastadl21.DesignFunctionType;
import org.eclipse.eatop.eastadl21.EAArrayValue;
import org.eclipse.eatop.eastadl21.EABoolean;
import org.eclipse.eatop.eastadl21.EABooleanValue;
import org.eclipse.eatop.eastadl21.EACompositeValue;
import org.eclipse.eatop.eastadl21.EADatatypePrototype;
import org.eclipse.eatop.eastadl21.EAEnumerationValue;
import org.eclipse.eatop.eastadl21.EAExpression;
import org.eclipse.eatop.eastadl21.EANumerical;
import org.eclipse.eatop.eastadl21.EANumericalValue;
import org.eclipse.eatop.eastadl21.EAPackage;
import org.eclipse.eatop.eastadl21.EAString;
import org.eclipse.eatop.eastadl21.EAStringValue;
import org.eclipse.eatop.eastadl21.Eastadl21Package;
import org.eclipse.eatop.eastadl21.ElectricalComponent;
import org.eclipse.eatop.eastadl21.Enumeration;
import org.eclipse.eatop.eastadl21.EnumerationLiteral;
import org.eclipse.eatop.eastadl21.FunctionAllocation;
import org.eclipse.eatop.eastadl21.FunctionAllocation_allocatedElement;
import org.eclipse.eatop.eastadl21.FunctionAllocation_target;
import org.eclipse.eatop.eastadl21.FunctionClientServerInterface;
import org.eclipse.eatop.eastadl21.FunctionClientServerPort;
import org.eclipse.eatop.eastadl21.FunctionConnector;
import org.eclipse.eatop.eastadl21.FunctionConnector_port;
import org.eclipse.eatop.eastadl21.FunctionFlowPort;
import org.eclipse.eatop.eastadl21.FunctionPowerPort;
import org.eclipse.eatop.eastadl21.HardwareComponentPrototype;
import org.eclipse.eatop.eastadl21.HardwareComponentType;
import org.eclipse.eatop.eastadl21.HardwareConnector;
import org.eclipse.eatop.eastadl21.HardwareConnector_port;
import org.eclipse.eatop.eastadl21.HardwareFunctionType;
import org.eclipse.eatop.eastadl21.HardwarePort;
import org.eclipse.eatop.eastadl21.HardwarePortConnector;
import org.eclipse.eatop.eastadl21.HardwarePortConnector_port;
import org.eclipse.eatop.eastadl21.IOHardwarePin;
import org.eclipse.eatop.eastadl21.LocalDeviceManager;
import org.eclipse.eatop.eastadl21.Node;
import org.eclipse.eatop.eastadl21.Operation;
import org.eclipse.eatop.eastadl21.PortGroup;
import org.eclipse.eatop.eastadl21.PowerHardwarePin;
import org.eclipse.eatop.eastadl21.Quantity;
import org.eclipse.eatop.eastadl21.RangeableValueType;
import org.eclipse.eatop.eastadl21.Rationale;
import org.eclipse.eatop.eastadl21.Realization;
import org.eclipse.eatop.eastadl21.Realization_realized;
import org.eclipse.eatop.eastadl21.Realization_realizedBy;
import org.eclipse.eatop.eastadl21.Sensor;
import org.eclipse.eatop.eastadl21.Unit;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class EastAdlSimplifiedSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EastAdlSimplifiedGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Eastadl21Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Eastadl21Package.ACTUATOR:
				sequence_Actuator(context, (Actuator) semanticObject); 
				return; 
			case Eastadl21Package.ALLOCATION:
				sequence_Allocation(context, (Allocation) semanticObject); 
				return; 
			case Eastadl21Package.ARRAY_DATATYPE:
				sequence_ArrayDatatype(context, (ArrayDatatype) semanticObject); 
				return; 
			case Eastadl21Package.BASIC_SOFTWARE_FUNCTION_TYPE:
				sequence_BasicSoftwareFunctionType(context, (BasicSoftwareFunctionType) semanticObject); 
				return; 
			case Eastadl21Package.COMMENT:
				sequence_Comment_Impl(context, (Comment) semanticObject); 
				return; 
			case Eastadl21Package.COMMUNICATION_HARDWARE_PIN:
				sequence_CommunicationHardwarePin(context, (CommunicationHardwarePin) semanticObject); 
				return; 
			case Eastadl21Package.COMPOSITE_DATATYPE:
				sequence_CompositeDatatype(context, (CompositeDatatype) semanticObject); 
				return; 
			case Eastadl21Package.DESIGN_FUNCTION_PROTOTYPE:
				sequence_DesignFunctionPrototype(context, (DesignFunctionPrototype) semanticObject); 
				return; 
			case Eastadl21Package.DESIGN_FUNCTION_TYPE:
				sequence_DesignFunctionType_Impl(context, (DesignFunctionType) semanticObject); 
				return; 
			case Eastadl21Package.EA_ARRAY_VALUE:
				sequence_EAArrayValue(context, (EAArrayValue) semanticObject); 
				return; 
			case Eastadl21Package.EA_BOOLEAN:
				sequence_EABoolean(context, (EABoolean) semanticObject); 
				return; 
			case Eastadl21Package.EA_BOOLEAN_VALUE:
				sequence_EABooleanValue(context, (EABooleanValue) semanticObject); 
				return; 
			case Eastadl21Package.EA_COMPOSITE_VALUE:
				sequence_EACompositeValue(context, (EACompositeValue) semanticObject); 
				return; 
			case Eastadl21Package.EA_DATATYPE_PROTOTYPE:
				sequence_EADatatypePrototype(context, (EADatatypePrototype) semanticObject); 
				return; 
			case Eastadl21Package.EA_ENUMERATION_VALUE:
				sequence_EAEnumerationValue(context, (EAEnumerationValue) semanticObject); 
				return; 
			case Eastadl21Package.EA_EXPRESSION:
				sequence_EAExpression(context, (EAExpression) semanticObject); 
				return; 
			case Eastadl21Package.EA_NUMERICAL:
				sequence_EANumerical(context, (EANumerical) semanticObject); 
				return; 
			case Eastadl21Package.EA_NUMERICAL_VALUE:
				sequence_EANumericalValue(context, (EANumericalValue) semanticObject); 
				return; 
			case Eastadl21Package.EA_PACKAGE:
				sequence_EAPackage(context, (EAPackage) semanticObject); 
				return; 
			case Eastadl21Package.EA_STRING:
				sequence_EAString(context, (EAString) semanticObject); 
				return; 
			case Eastadl21Package.EA_STRING_VALUE:
				sequence_EAStringValue(context, (EAStringValue) semanticObject); 
				return; 
			case Eastadl21Package.ELECTRICAL_COMPONENT:
				sequence_ElectricalComponent(context, (ElectricalComponent) semanticObject); 
				return; 
			case Eastadl21Package.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case Eastadl21Package.ENUMERATION_LITERAL:
				sequence_EnumerationLiteral(context, (EnumerationLiteral) semanticObject); 
				return; 
			case Eastadl21Package.FUNCTION_ALLOCATION:
				sequence_FunctionAllocation(context, (FunctionAllocation) semanticObject); 
				return; 
			case Eastadl21Package.FUNCTION_ALLOCATION_ALLOCATED_ELEMENT:
				sequence_FunctionAllocation_allocatedElement(context, (FunctionAllocation_allocatedElement) semanticObject); 
				return; 
			case Eastadl21Package.FUNCTION_ALLOCATION_TARGET:
				sequence_FunctionAllocation_target(context, (FunctionAllocation_target) semanticObject); 
				return; 
			case Eastadl21Package.FUNCTION_CLIENT_SERVER_INTERFACE:
				sequence_FunctionClientServerInterface(context, (FunctionClientServerInterface) semanticObject); 
				return; 
			case Eastadl21Package.FUNCTION_CLIENT_SERVER_PORT:
				sequence_FunctionClientServerPort(context, (FunctionClientServerPort) semanticObject); 
				return; 
			case Eastadl21Package.FUNCTION_CONNECTOR:
				sequence_FunctionConnector(context, (FunctionConnector) semanticObject); 
				return; 
			case Eastadl21Package.FUNCTION_CONNECTOR_PORT:
				sequence_FunctionConnector_port(context, (FunctionConnector_port) semanticObject); 
				return; 
			case Eastadl21Package.FUNCTION_FLOW_PORT:
				sequence_FunctionFlowPort(context, (FunctionFlowPort) semanticObject); 
				return; 
			case Eastadl21Package.FUNCTION_POWER_PORT:
				sequence_FunctionPowerPort(context, (FunctionPowerPort) semanticObject); 
				return; 
			case Eastadl21Package.HARDWARE_COMPONENT_PROTOTYPE:
				sequence_HardwareComponentPrototype(context, (HardwareComponentPrototype) semanticObject); 
				return; 
			case Eastadl21Package.HARDWARE_COMPONENT_TYPE:
				sequence_HardwareComponentType_Impl(context, (HardwareComponentType) semanticObject); 
				return; 
			case Eastadl21Package.HARDWARE_CONNECTOR:
				sequence_HardwareConnector(context, (HardwareConnector) semanticObject); 
				return; 
			case Eastadl21Package.HARDWARE_CONNECTOR_PORT:
				sequence_HardwareConnector_port(context, (HardwareConnector_port) semanticObject); 
				return; 
			case Eastadl21Package.HARDWARE_FUNCTION_TYPE:
				sequence_HardwareFunctionType(context, (HardwareFunctionType) semanticObject); 
				return; 
			case Eastadl21Package.HARDWARE_PORT:
				sequence_HardwarePort(context, (HardwarePort) semanticObject); 
				return; 
			case Eastadl21Package.HARDWARE_PORT_CONNECTOR:
				sequence_HardwarePortConnector(context, (HardwarePortConnector) semanticObject); 
				return; 
			case Eastadl21Package.HARDWARE_PORT_CONNECTOR_PORT:
				sequence_HardwarePortConnector_port(context, (HardwarePortConnector_port) semanticObject); 
				return; 
			case Eastadl21Package.IO_HARDWARE_PIN:
				sequence_IOHardwarePin(context, (IOHardwarePin) semanticObject); 
				return; 
			case Eastadl21Package.LOCAL_DEVICE_MANAGER:
				sequence_LocalDeviceManager(context, (LocalDeviceManager) semanticObject); 
				return; 
			case Eastadl21Package.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case Eastadl21Package.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case Eastadl21Package.PORT_GROUP:
				sequence_PortGroup(context, (PortGroup) semanticObject); 
				return; 
			case Eastadl21Package.POWER_HARDWARE_PIN:
				sequence_PowerHardwarePin(context, (PowerHardwarePin) semanticObject); 
				return; 
			case Eastadl21Package.QUANTITY:
				sequence_Quantity(context, (Quantity) semanticObject); 
				return; 
			case Eastadl21Package.RANGEABLE_VALUE_TYPE:
				sequence_RangeableValueType(context, (RangeableValueType) semanticObject); 
				return; 
			case Eastadl21Package.RATIONALE:
				sequence_Rationale(context, (Rationale) semanticObject); 
				return; 
			case Eastadl21Package.REALIZATION:
				sequence_Realization(context, (Realization) semanticObject); 
				return; 
			case Eastadl21Package.REALIZATION_REALIZED:
				sequence_Realization_realized(context, (Realization_realized) semanticObject); 
				return; 
			case Eastadl21Package.REALIZATION_REALIZED_BY:
				sequence_Realization_realizedBy(context, (Realization_realizedBy) semanticObject); 
				return; 
			case Eastadl21Package.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case Eastadl21Package.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     HardwareComponentType returns Actuator
	 *     EAElement returns Actuator
	 *     Actuator returns Actuator
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (pin+=HardwarePin pin+=HardwarePin*)? 
	 *         (part+=HardwareComponentPrototype part+=HardwareComponentPrototype*)? 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)? 
	 *         (port+=HardwarePort port+=HardwarePort*)?
	 *     )
	 */
	protected void sequence_Actuator(ISerializationContext context, Actuator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAElement returns Allocation
	 *     Allocation returns Allocation
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (functionAllocation+=FunctionAllocation functionAllocation+=FunctionAllocation*)?
	 *     )
	 */
	protected void sequence_Allocation(ISerializationContext context, Allocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TraceableSpecification returns ArrayDatatype
	 *     EADatatype returns ArrayDatatype
	 *     EAElement returns ArrayDatatype
	 *     ArrayDatatype returns ArrayDatatype
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         maxLength=Integer? 
	 *         minLength=Integer? 
	 *         elementType=[EADatatype|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_ArrayDatatype(ISerializationContext context, ArrayDatatype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DesignFunctionType returns BasicSoftwareFunctionType
	 *     EAElement returns BasicSoftwareFunctionType
	 *     BasicSoftwareFunctionType returns BasicSoftwareFunctionType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isElementary=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)? 
	 *         (connector+=FunctionConnector connector+=FunctionConnector*)? 
	 *         (port+=FunctionPort port+=FunctionPort*)? 
	 *         (part+=DesignFunctionPrototype part+=DesignFunctionPrototype*)?
	 *     )
	 */
	protected void sequence_BasicSoftwareFunctionType(ISerializationContext context, BasicSoftwareFunctionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Comment returns Comment
	 *     Comment_Impl returns Comment
	 *
	 * Constraint:
	 *     body=String0
	 */
	protected void sequence_Comment_Impl(ISerializationContext context, Comment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Eastadl21Package.Literals.COMMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl21Package.Literals.COMMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComment_ImplAccess().getBodyString0ParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     HardwarePin returns CommunicationHardwarePin
	 *     AllocationTarget returns CommunicationHardwarePin
	 *     EAElement returns CommunicationHardwarePin
	 *     CommunicationHardwarePin returns CommunicationHardwarePin
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         direction=EADirectionKind? 
	 *         isGround=Boolean? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_CommunicationHardwarePin(ISerializationContext context, CommunicationHardwarePin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TraceableSpecification returns CompositeDatatype
	 *     EADatatype returns CompositeDatatype
	 *     EAElement returns CompositeDatatype
	 *     CompositeDatatype returns CompositeDatatype
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         datatypePrototype+=EADatatypePrototype 
	 *         datatypePrototype+=EADatatypePrototype*
	 *     )
	 */
	protected void sequence_CompositeDatatype(ISerializationContext context, CompositeDatatype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllocateableElement returns DesignFunctionPrototype
	 *     FunctionPrototype returns DesignFunctionPrototype
	 *     EAElement returns DesignFunctionPrototype
	 *     DesignFunctionPrototype returns DesignFunctionPrototype
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         type=[DesignFunctionType|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_DesignFunctionPrototype(ISerializationContext context, DesignFunctionPrototype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DesignFunctionType returns DesignFunctionType
	 *     EAElement returns DesignFunctionType
	 *     DesignFunctionType_Impl returns DesignFunctionType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isElementary=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)? 
	 *         (connector+=FunctionConnector connector+=FunctionConnector*)? 
	 *         (port+=FunctionPort port+=FunctionPort*)? 
	 *         (part+=DesignFunctionPrototype part+=DesignFunctionPrototype*)?
	 *     )
	 */
	protected void sequence_DesignFunctionType_Impl(ISerializationContext context, DesignFunctionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EAArrayValue
	 *     EAArrayValue returns EAArrayValue
	 *
	 * Constraint:
	 *     (type=[EADatatype|EString] (value+=EAValue value+=EAValue*)?)
	 */
	protected void sequence_EAArrayValue(ISerializationContext context, EAArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EABooleanValue
	 *     EABooleanValue returns EABooleanValue
	 *
	 * Constraint:
	 *     (value=Boolean type=[EADatatype|EString])
	 */
	protected void sequence_EABooleanValue(ISerializationContext context, EABooleanValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Eastadl21Package.Literals.EA_BOOLEAN_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl21Package.Literals.EA_BOOLEAN_VALUE__VALUE));
			if (transientValues.isValueTransient(semanticObject, Eastadl21Package.Literals.EA_VALUE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl21Package.Literals.EA_VALUE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEABooleanValueAccess().getValueBooleanParserRuleCall_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEABooleanValueAccess().getTypeEADatatypeEStringParserRuleCall_4_0_1(), semanticObject.eGet(Eastadl21Package.Literals.EA_VALUE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TraceableSpecification returns EABoolean
	 *     EADatatype returns EABoolean
	 *     EAElement returns EABoolean
	 *     EABoolean returns EABoolean
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_EABoolean(ISerializationContext context, EABoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EACompositeValue
	 *     EACompositeValue returns EACompositeValue
	 *
	 * Constraint:
	 *     (type=[EADatatype|EString] value+=EAValue value+=EAValue*)
	 */
	protected void sequence_EACompositeValue(ISerializationContext context, EACompositeValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAElement returns EADatatypePrototype
	 *     EADatatypePrototype returns EADatatypePrototype
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         type=[EADatatype|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_EADatatypePrototype(ISerializationContext context, EADatatypePrototype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EAEnumerationValue
	 *     EAEnumerationValue returns EAEnumerationValue
	 *
	 * Constraint:
	 *     (type=[EADatatype|EString] value+=[EnumerationLiteral|EString] value+=[EnumerationLiteral|EString]*)
	 */
	protected void sequence_EAEnumerationValue(ISerializationContext context, EAEnumerationValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EAExpression
	 *     EAExpression returns EAExpression
	 *
	 * Constraint:
	 *     (type=[EADatatype|EString] (value+=EAValue value+=EAValue*)?)
	 */
	protected void sequence_EAExpression(ISerializationContext context, EAExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EANumericalValue
	 *     EANumericalValue returns EANumericalValue
	 *
	 * Constraint:
	 *     (value=Numerical type=[EADatatype|EString])
	 */
	protected void sequence_EANumericalValue(ISerializationContext context, EANumericalValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Eastadl21Package.Literals.EA_NUMERICAL_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl21Package.Literals.EA_NUMERICAL_VALUE__VALUE));
			if (transientValues.isValueTransient(semanticObject, Eastadl21Package.Literals.EA_VALUE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl21Package.Literals.EA_VALUE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEANumericalValueAccess().getValueNumericalParserRuleCall_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEANumericalValueAccess().getTypeEADatatypeEStringParserRuleCall_4_0_1(), semanticObject.eGet(Eastadl21Package.Literals.EA_VALUE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TraceableSpecification returns EANumerical
	 *     EADatatype returns EANumerical
	 *     EAElement returns EANumerical
	 *     EANumerical returns EANumerical
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         max=Numerical? 
	 *         min=Numerical? 
	 *         unit=[Unit|EString]? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_EANumerical(ISerializationContext context, EANumerical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAElement returns EAPackage
	 *     EAPackage returns EAPackage
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (subPackage+=EAPackage subPackage+=EAPackage*)?
	 *     )
	 */
	protected void sequence_EAPackage(ISerializationContext context, EAPackage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EAStringValue
	 *     EAStringValue returns EAStringValue
	 *
	 * Constraint:
	 *     (value=String0 type=[EADatatype|EString])
	 */
	protected void sequence_EAStringValue(ISerializationContext context, EAStringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Eastadl21Package.Literals.EA_STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl21Package.Literals.EA_STRING_VALUE__VALUE));
			if (transientValues.isValueTransient(semanticObject, Eastadl21Package.Literals.EA_VALUE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl21Package.Literals.EA_VALUE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEAStringValueAccess().getValueString0ParserRuleCall_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEAStringValueAccess().getTypeEADatatypeEStringParserRuleCall_4_0_1(), semanticObject.eGet(Eastadl21Package.Literals.EA_VALUE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TraceableSpecification returns EAString
	 *     EADatatype returns EAString
	 *     EAElement returns EAString
	 *     EAString returns EAString
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_EAString(ISerializationContext context, EAString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwareComponentType returns ElectricalComponent
	 *     EAElement returns ElectricalComponent
	 *     ElectricalComponent returns ElectricalComponent
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isActive=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (pin+=HardwarePin pin+=HardwarePin*)? 
	 *         (part+=HardwareComponentPrototype part+=HardwareComponentPrototype*)? 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)? 
	 *         (port+=HardwarePort port+=HardwarePort*)?
	 *     )
	 */
	protected void sequence_ElectricalComponent(ISerializationContext context, ElectricalComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAElement returns EnumerationLiteral
	 *     EnumerationLiteral returns EnumerationLiteral
	 *
	 * Constraint:
	 *     (shortName=Identifier category=Identifier? uuid=String0? name=String0? (ownedComment+=Comment ownedComment+=Comment*)?)
	 */
	protected void sequence_EnumerationLiteral(ISerializationContext context, EnumerationLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TraceableSpecification returns Enumeration
	 *     EADatatype returns Enumeration
	 *     EAElement returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         isMultiValued=Boolean 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         literal+=EnumerationLiteral 
	 *         literal+=EnumerationLiteral*
	 *     )
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAElement returns FunctionAllocation
	 *     FunctionAllocation returns FunctionAllocation
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         allocatedElement=FunctionAllocation_allocatedElement 
	 *         target=FunctionAllocation_target
	 *     )
	 */
	protected void sequence_FunctionAllocation(ISerializationContext context, FunctionAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionAllocation_allocatedElement returns FunctionAllocation_allocatedElement
	 *
	 * Constraint:
	 *     (
	 *         (allocateableElement_context+=[AllocateableElement|EString] allocateableElement_context+=[AllocateableElement|EString]*)? 
	 *         allocateableElement=[AllocateableElement|EString]
	 *     )
	 */
	protected void sequence_FunctionAllocation_allocatedElement(ISerializationContext context, FunctionAllocation_allocatedElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionAllocation_target returns FunctionAllocation_target
	 *
	 * Constraint:
	 *     (
	 *         (allocationTarget_context+=[AllocationTarget|EString] allocationTarget_context+=[AllocationTarget|EString]*)? 
	 *         allocationTarget=[AllocationTarget|EString]
	 *     )
	 */
	protected void sequence_FunctionAllocation_target(ISerializationContext context, FunctionAllocation_target semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TraceableSpecification returns FunctionClientServerInterface
	 *     EAElement returns FunctionClientServerInterface
	 *     FunctionClientServerInterface returns FunctionClientServerInterface
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (operation+=Operation operation+=Operation*)?
	 *     )
	 */
	protected void sequence_FunctionClientServerInterface(ISerializationContext context, FunctionClientServerInterface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionPort returns FunctionClientServerPort
	 *     AllocateableElement returns FunctionClientServerPort
	 *     EAElement returns FunctionClientServerPort
	 *     FunctionClientServerPort returns FunctionClientServerPort
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         kind=ClientServerKind 
	 *         type=[FunctionClientServerInterface|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_FunctionClientServerPort(ISerializationContext context, FunctionClientServerPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllocateableElement returns FunctionConnector
	 *     EAElement returns FunctionConnector
	 *     FunctionConnector returns FunctionConnector
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         port+=FunctionConnector_port 
	 *         port+=FunctionConnector_port*
	 *     )
	 */
	protected void sequence_FunctionConnector(ISerializationContext context, FunctionConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionConnector_port returns FunctionConnector_port
	 *
	 * Constraint:
	 *     (functionPrototype=[FunctionPrototype|EString]? functionPort=[FunctionPort|EString])
	 */
	protected void sequence_FunctionConnector_port(ISerializationContext context, FunctionConnector_port semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionPort returns FunctionFlowPort
	 *     AllocateableElement returns FunctionFlowPort
	 *     EAElement returns FunctionFlowPort
	 *     FunctionFlowPort returns FunctionFlowPort
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         direction=EADirectionKind 
	 *         type=[EADatatype|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         defaultValue=EAValue?
	 *     )
	 */
	protected void sequence_FunctionFlowPort(ISerializationContext context, FunctionFlowPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionPort returns FunctionPowerPort
	 *     AllocateableElement returns FunctionPowerPort
	 *     EAElement returns FunctionPowerPort
	 *     FunctionPowerPort returns FunctionPowerPort
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         type=[CompositeDatatype|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_FunctionPowerPort(ISerializationContext context, FunctionPowerPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllocationTarget returns HardwareComponentPrototype
	 *     EAElement returns HardwareComponentPrototype
	 *     HardwareComponentPrototype returns HardwareComponentPrototype
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         type=[HardwareComponentType|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_HardwareComponentPrototype(ISerializationContext context, HardwareComponentPrototype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwareComponentType returns HardwareComponentType
	 *     EAElement returns HardwareComponentType
	 *     HardwareComponentType_Impl returns HardwareComponentType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (pin+=HardwarePin pin+=HardwarePin*)? 
	 *         (part+=HardwareComponentPrototype part+=HardwareComponentPrototype*)? 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)? 
	 *         (port+=HardwarePort port+=HardwarePort*)?
	 *     )
	 */
	protected void sequence_HardwareComponentType_Impl(ISerializationContext context, HardwareComponentType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAElement returns HardwareConnector
	 *     HardwareConnector returns HardwareConnector
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         port+=HardwareConnector_port 
	 *         port+=HardwareConnector_port*
	 *     )
	 */
	protected void sequence_HardwareConnector(ISerializationContext context, HardwareConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwareConnector_port returns HardwareConnector_port
	 *
	 * Constraint:
	 *     (hardwarePin=[HardwarePin|EString] hardwareComponentPrototype=[HardwareComponentPrototype|EString]?)
	 */
	protected void sequence_HardwareConnector_port(ISerializationContext context, HardwareConnector_port semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DesignFunctionType returns HardwareFunctionType
	 *     EAElement returns HardwareFunctionType
	 *     HardwareFunctionType returns HardwareFunctionType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isElementary=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         hardwareComponent=[HardwareComponentType|EString]? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)? 
	 *         (connector+=FunctionConnector connector+=FunctionConnector*)? 
	 *         (port+=FunctionPort port+=FunctionPort*)? 
	 *         (part+=DesignFunctionPrototype part+=DesignFunctionPrototype*)?
	 *     )
	 */
	protected void sequence_HardwareFunctionType(ISerializationContext context, HardwareFunctionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllocationTarget returns HardwarePortConnector
	 *     EAElement returns HardwarePortConnector
	 *     HardwarePortConnector returns HardwarePortConnector
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         port+=HardwarePortConnector_port 
	 *         port+=HardwarePortConnector_port* 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)?
	 *     )
	 */
	protected void sequence_HardwarePortConnector(ISerializationContext context, HardwarePortConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwarePortConnector_port returns HardwarePortConnector_port
	 *
	 * Constraint:
	 *     (hardwarePort=[HardwarePort|EString] hardwareComponentPrototype=[HardwareComponentPrototype|EString]?)
	 */
	protected void sequence_HardwarePortConnector_port(ISerializationContext context, HardwarePortConnector_port semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllocationTarget returns HardwarePort
	 *     EAElement returns HardwarePort
	 *     HardwarePort returns HardwarePort
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isShield=Boolean? 
	 *         (referencedPin+=[HardwarePin|EString] referencedPin+=[HardwarePin|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (containedPin+=HardwarePin containedPin+=HardwarePin*)? 
	 *         (containedPort+=HardwarePort containedPort+=HardwarePort*)?
	 *     )
	 */
	protected void sequence_HardwarePort(ISerializationContext context, HardwarePort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwarePin returns IOHardwarePin
	 *     AllocationTarget returns IOHardwarePin
	 *     EAElement returns IOHardwarePin
	 *     IOHardwarePin returns IOHardwarePin
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         direction=EADirectionKind? 
	 *         isGround=Boolean? 
	 *         kind=IOHardwarePinKind? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_IOHardwarePin(ISerializationContext context, IOHardwarePin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DesignFunctionType returns LocalDeviceManager
	 *     EAElement returns LocalDeviceManager
	 *     LocalDeviceManager returns LocalDeviceManager
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isElementary=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)? 
	 *         (connector+=FunctionConnector connector+=FunctionConnector*)? 
	 *         (port+=FunctionPort port+=FunctionPort*)? 
	 *         (part+=DesignFunctionPrototype part+=DesignFunctionPrototype*)?
	 *     )
	 */
	protected void sequence_LocalDeviceManager(ISerializationContext context, LocalDeviceManager semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwareComponentType returns Node
	 *     EAElement returns Node
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         executionRate=Float? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (pin+=HardwarePin pin+=HardwarePin*)? 
	 *         (part+=HardwareComponentPrototype part+=HardwareComponentPrototype*)? 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)? 
	 *         (port+=HardwarePort port+=HardwarePort*)?
	 *     )
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAElement returns Operation
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         return=EADatatypePrototype? 
	 *         (argument+=EADatatypePrototype argument+=EADatatypePrototype*)?
	 *     )
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAElement returns PortGroup
	 *     PortGroup returns PortGroup
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (port+=[FunctionPort|EString] port+=[FunctionPort|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)?
	 *     )
	 */
	protected void sequence_PortGroup(ISerializationContext context, PortGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwarePin returns PowerHardwarePin
	 *     AllocationTarget returns PowerHardwarePin
	 *     EAElement returns PowerHardwarePin
	 *     PowerHardwarePin returns PowerHardwarePin
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         direction=EADirectionKind? 
	 *         isGround=Boolean? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_PowerHardwarePin(ISerializationContext context, PowerHardwarePin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAElement returns Quantity
	 *     Quantity returns Quantity
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         amountOfSubstanceExp=Integer 
	 *         electricCurrentExp=Integer 
	 *         lengthExp=Integer 
	 *         luminousIntensityExp=Integer 
	 *         massExp=Integer 
	 *         thermodynamicTemperatureExp=Integer 
	 *         timeExp=Integer 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_Quantity(ISerializationContext context, Quantity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TraceableSpecification returns RangeableValueType
	 *     EADatatype returns RangeableValueType
	 *     EAElement returns RangeableValueType
	 *     RangeableValueType returns RangeableValueType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         accuracy=Float 
	 *         resolution=Float 
	 *         significantDigits=Integer? 
	 *         baseRangeable=[EANumerical|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_RangeableValueType(ISerializationContext context, RangeableValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Comment returns Rationale
	 *     Rationale returns Rationale
	 *
	 * Constraint:
	 *     body=String0
	 */
	protected void sequence_Rationale(ISerializationContext context, Rationale semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Eastadl21Package.Literals.COMMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl21Package.Literals.COMMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRationaleAccess().getBodyString0ParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Relationship returns Realization
	 *     EAElement returns Realization
	 *     Realization returns Realization
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         realized+=Realization_realized 
	 *         realized+=Realization_realized* 
	 *         realizedBy+=Realization_realizedBy 
	 *         realizedBy+=Realization_realizedBy*
	 *     )
	 */
	protected void sequence_Realization(ISerializationContext context, Realization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Realization_realizedBy returns Realization_realizedBy
	 *
	 * Constraint:
	 *     (identifiable_target=[Identifiable|EString] (identifiable_context+=[Identifiable|EString] identifiable_context+=[Identifiable|EString]*)?)
	 */
	protected void sequence_Realization_realizedBy(ISerializationContext context, Realization_realizedBy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Realization_realized returns Realization_realized
	 *
	 * Constraint:
	 *     (identifiable_target=[EAElement|EString] (identifiable_context+=[EAElement|EString] identifiable_context+=[EAElement|EString]*)?)
	 */
	protected void sequence_Realization_realized(ISerializationContext context, Realization_realized semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwareComponentType returns Sensor
	 *     EAElement returns Sensor
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (pin+=HardwarePin pin+=HardwarePin*)? 
	 *         (part+=HardwareComponentPrototype part+=HardwareComponentPrototype*)? 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)? 
	 *         (port+=HardwarePort port+=HardwarePort*)?
	 *     )
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAElement returns Unit
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         factor=Float 
	 *         symbol=String0 
	 *         offset=Float 
	 *         reference=[Unit|EString]? 
	 *         quantity=[Quantity|EString]? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
