/*
 * generated by Xtext 2.25.0
 */
package org.bumble.eatxt.formatting2

import org.eclipse.eatop.eastadl22.Actuator
import org.eclipse.eatop.eastadl22.Allocation
import org.eclipse.eatop.eastadl22.AnalysisFunctionPrototype
import org.eclipse.eatop.eastadl22.AnalysisFunctionType
import org.eclipse.eatop.eastadl22.ArrayDatatype
import org.eclipse.eatop.eastadl22.BasicSoftwareFunctionType
import org.eclipse.eatop.eastadl22.CommunicationHardwarePin
import org.eclipse.eatop.eastadl22.CompositeDatatype
import org.eclipse.eatop.eastadl22.DesignFunctionPrototype
import org.eclipse.eatop.eastadl22.DesignFunctionType
import org.eclipse.eatop.eastadl22.DesignLevel
import org.eclipse.eatop.eastadl22.EAArrayValue
import org.eclipse.eatop.eastadl22.EABoolean
import org.eclipse.eatop.eastadl22.EACompositeValue
import org.eclipse.eatop.eastadl22.EADatatypePrototype
import org.eclipse.eatop.eastadl22.EAExpression
import org.eclipse.eatop.eastadl22.EANumerical
import org.eclipse.eatop.eastadl22.EAPackage
import org.eclipse.eatop.eastadl22.EAString
import org.eclipse.eatop.eastadl22.EAXML
import org.eclipse.eatop.eastadl22.ElectricalComponent
import org.eclipse.eatop.eastadl22.Enumeration
import org.eclipse.eatop.eastadl22.EnumerationLiteral
import org.eclipse.eatop.eastadl22.FunctionAllocation
import org.eclipse.eatop.eastadl22.FunctionClientServerInterface
import org.eclipse.eatop.eastadl22.FunctionClientServerPort
import org.eclipse.eatop.eastadl22.FunctionConnector
import org.eclipse.eatop.eastadl22.FunctionFlowPort
import org.eclipse.eatop.eastadl22.FunctionPowerPort
import org.eclipse.eatop.eastadl22.FunctionalDevice
import org.eclipse.eatop.eastadl22.HardwareComponentPrototype
import org.eclipse.eatop.eastadl22.HardwareComponentType
import org.eclipse.eatop.eastadl22.HardwareConnector
import org.eclipse.eatop.eastadl22.HardwareFunctionType
import org.eclipse.eatop.eastadl22.HardwarePort
import org.eclipse.eatop.eastadl22.HardwarePortConnector
import org.eclipse.eatop.eastadl22.IOHardwarePin
import org.eclipse.eatop.eastadl22.LocalDeviceManager
import org.eclipse.eatop.eastadl22.LogicalPortConnector
import org.eclipse.eatop.eastadl22.Node
import org.eclipse.eatop.eastadl22.Operation
import org.eclipse.eatop.eastadl22.PortGroup
import org.eclipse.eatop.eastadl22.PowerHardwarePin
import org.eclipse.eatop.eastadl22.Quantity
import org.eclipse.eatop.eastadl22.RangeableValueType
import org.eclipse.eatop.eastadl22.Realization
import org.eclipse.eatop.eastadl22.Sensor
import org.eclipse.eatop.eastadl22.Unit
import org.eclipse.eatop.eastadl22.UserAttributeDefinition
import org.eclipse.eatop.eastadl22.UserAttributedElement
import org.eclipse.eatop.eastadl22.UserElementType
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument

class EatxtFormatter extends AbstractFormatter2 {
		
		
		def dispatch void format(EAXML eAXML, extension IFormattableDocument document) {
			val open = eAXML.regionFor.keyword('{')
			val close = eAXML.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : eAXML.eClass.EAllAttributes) {
				
				val attrRegion = eAXML.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (eAPackage : eAXML.topLevelPackage) {
				eAPackage.format
			}
			
		}
		
		def dispatch void format(EAPackage eAPackage, extension IFormattableDocument document) {
			val open = eAPackage.regionFor.keyword('{')
			val close = eAPackage.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : eAPackage.eClass.EAllAttributes) {
				
				val attrRegion = eAPackage.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : eAPackage.ownedComment) {
				comment.format
			}
			
			for (_eAPackage : eAPackage.subPackage) {
				_eAPackage.format
			}
			
			for (eAPackageableElement : eAPackage.element) {
				eAPackageableElement.format
			}
			
		}
		
		def dispatch void format(DesignLevel designLevel, extension IFormattableDocument document) {
			val open = designLevel.regionFor.keyword('{')
			val close = designLevel.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : designLevel.eClass.EAllAttributes) {
				
				val attrRegion = designLevel.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : designLevel.ownedComment) {
				comment.format
			}
			
			for (relationship : designLevel.ownedRelationship) {
				relationship.format
			}
			
			for (allocation : designLevel.allocation) {
				allocation.format
			}
			
			designLevel.functionalDesignArchitecture.format
			designLevel.hardwareDesignArchitecture.format
		}
		
		def dispatch void format(AnalysisFunctionType analysisFunctionType, extension IFormattableDocument document) {
			val open = analysisFunctionType.regionFor.keyword('{')
			val close = analysisFunctionType.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : analysisFunctionType.eClass.EAllAttributes) {
				
				val attrRegion = analysisFunctionType.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : analysisFunctionType.ownedComment) {
				comment.format
			}
			
			for (relationship : analysisFunctionType.ownedRelationship) {
				relationship.format
			}
			
			for (portGroup : analysisFunctionType.portGroup) {
				portGroup.format
			}
			
			for (functionConnector : analysisFunctionType.connector) {
				functionConnector.format
			}
			
			for (functionPort : analysisFunctionType.port) {
				functionPort.format
			}
			
			for (analysisFunctionPrototype : analysisFunctionType.part) {
				analysisFunctionPrototype.format
			}
			
		}
		
		def dispatch void format(BasicSoftwareFunctionType basicSoftwareFunctionType, extension IFormattableDocument document) {
			val open = basicSoftwareFunctionType.regionFor.keyword('{')
			val close = basicSoftwareFunctionType.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : basicSoftwareFunctionType.eClass.EAllAttributes) {
				
				val attrRegion = basicSoftwareFunctionType.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : basicSoftwareFunctionType.ownedComment) {
				comment.format
			}
			
			for (relationship : basicSoftwareFunctionType.ownedRelationship) {
				relationship.format
			}
			
			for (portGroup : basicSoftwareFunctionType.portGroup) {
				portGroup.format
			}
			
			for (functionConnector : basicSoftwareFunctionType.connector) {
				functionConnector.format
			}
			
			for (functionPort : basicSoftwareFunctionType.port) {
				functionPort.format
			}
			
			for (designFunctionPrototype : basicSoftwareFunctionType.part) {
				designFunctionPrototype.format
			}
			
		}
		
		def dispatch void format(DesignFunctionType designFunctionType, extension IFormattableDocument document) {
			val open = designFunctionType.regionFor.keyword('{')
			val close = designFunctionType.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : designFunctionType.eClass.EAllAttributes) {
				
				val attrRegion = designFunctionType.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : designFunctionType.ownedComment) {
				comment.format
			}
			
			for (relationship : designFunctionType.ownedRelationship) {
				relationship.format
			}
			
			for (portGroup : designFunctionType.portGroup) {
				portGroup.format
			}
			
			for (functionConnector : designFunctionType.connector) {
				functionConnector.format
			}
			
			for (functionPort : designFunctionType.port) {
				functionPort.format
			}
			
			for (designFunctionPrototype : designFunctionType.part) {
				designFunctionPrototype.format
			}
			
		}
		
		def dispatch void format(FunctionalDevice functionalDevice, extension IFormattableDocument document) {
			val open = functionalDevice.regionFor.keyword('{')
			val close = functionalDevice.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : functionalDevice.eClass.EAllAttributes) {
				
				val attrRegion = functionalDevice.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : functionalDevice.ownedComment) {
				comment.format
			}
			
			for (relationship : functionalDevice.ownedRelationship) {
				relationship.format
			}
			
			for (portGroup : functionalDevice.portGroup) {
				portGroup.format
			}
			
			for (functionConnector : functionalDevice.connector) {
				functionConnector.format
			}
			
			for (functionPort : functionalDevice.port) {
				functionPort.format
			}
			
			for (analysisFunctionPrototype : functionalDevice.part) {
				analysisFunctionPrototype.format
			}
			
		}
		
		def dispatch void format(FunctionClientServerInterface functionClientServerInterface, extension IFormattableDocument document) {
			val open = functionClientServerInterface.regionFor.keyword('{')
			val close = functionClientServerInterface.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : functionClientServerInterface.eClass.EAllAttributes) {
				
				val attrRegion = functionClientServerInterface.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : functionClientServerInterface.ownedComment) {
				comment.format
			}
			
			for (operation : functionClientServerInterface.operation) {
				operation.format
			}
			
		}
		
		def dispatch void format(HardwareFunctionType hardwareFunctionType, extension IFormattableDocument document) {
			val open = hardwareFunctionType.regionFor.keyword('{')
			val close = hardwareFunctionType.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : hardwareFunctionType.eClass.EAllAttributes) {
				
				val attrRegion = hardwareFunctionType.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : hardwareFunctionType.ownedComment) {
				comment.format
			}
			
			for (relationship : hardwareFunctionType.ownedRelationship) {
				relationship.format
			}
			
			for (portGroup : hardwareFunctionType.portGroup) {
				portGroup.format
			}
			
			for (functionConnector : hardwareFunctionType.connector) {
				functionConnector.format
			}
			
			for (functionPort : hardwareFunctionType.port) {
				functionPort.format
			}
			
			for (designFunctionPrototype : hardwareFunctionType.part) {
				designFunctionPrototype.format
			}
			
		}
		
		def dispatch void format(LocalDeviceManager localDeviceManager, extension IFormattableDocument document) {
			val open = localDeviceManager.regionFor.keyword('{')
			val close = localDeviceManager.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : localDeviceManager.eClass.EAllAttributes) {
				
				val attrRegion = localDeviceManager.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : localDeviceManager.ownedComment) {
				comment.format
			}
			
			for (relationship : localDeviceManager.ownedRelationship) {
				relationship.format
			}
			
			for (portGroup : localDeviceManager.portGroup) {
				portGroup.format
			}
			
			for (functionConnector : localDeviceManager.connector) {
				functionConnector.format
			}
			
			for (functionPort : localDeviceManager.port) {
				functionPort.format
			}
			
			for (designFunctionPrototype : localDeviceManager.part) {
				designFunctionPrototype.format
			}
			
		}
		
		def dispatch void format(Actuator actuator, extension IFormattableDocument document) {
			val open = actuator.regionFor.keyword('{')
			val close = actuator.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : actuator.eClass.EAllAttributes) {
				
				val attrRegion = actuator.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : actuator.ownedComment) {
				comment.format
			}
			
			for (relationship : actuator.ownedRelationship) {
				relationship.format
			}
			
			for (hardwarePin : actuator.pin) {
				hardwarePin.format
			}
			
			for (hardwareComponentPrototype : actuator.part) {
				hardwareComponentPrototype.format
			}
			
			for (hardwareConnector : actuator.connector) {
				hardwareConnector.format
			}
			
			for (hardwarePort : actuator.port) {
				hardwarePort.format
			}
			
			for (portConnector : actuator.portConnector) {
				portConnector.format
			}
			
		}
		
		def dispatch void format(ElectricalComponent electricalComponent, extension IFormattableDocument document) {
			val open = electricalComponent.regionFor.keyword('{')
			val close = electricalComponent.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : electricalComponent.eClass.EAllAttributes) {
				
				val attrRegion = electricalComponent.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : electricalComponent.ownedComment) {
				comment.format
			}
			
			for (relationship : electricalComponent.ownedRelationship) {
				relationship.format
			}
			
			for (hardwarePin : electricalComponent.pin) {
				hardwarePin.format
			}
			
			for (hardwareComponentPrototype : electricalComponent.part) {
				hardwareComponentPrototype.format
			}
			
			for (hardwareConnector : electricalComponent.connector) {
				hardwareConnector.format
			}
			
			for (hardwarePort : electricalComponent.port) {
				hardwarePort.format
			}
			
			for (portConnector : electricalComponent.portConnector) {
				portConnector.format
			}
			
		}
		
		def dispatch void format(HardwareComponentType hardwareComponentType, extension IFormattableDocument document) {
			val open = hardwareComponentType.regionFor.keyword('{')
			val close = hardwareComponentType.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : hardwareComponentType.eClass.EAllAttributes) {
				
				val attrRegion = hardwareComponentType.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : hardwareComponentType.ownedComment) {
				comment.format
			}
			
			for (relationship : hardwareComponentType.ownedRelationship) {
				relationship.format
			}
			
			for (hardwarePin : hardwareComponentType.pin) {
				hardwarePin.format
			}
			
			for (hardwareComponentPrototype : hardwareComponentType.part) {
				hardwareComponentPrototype.format
			}
			
			for (hardwareConnector : hardwareComponentType.connector) {
				hardwareConnector.format
			}
			
			for (hardwarePort : hardwareComponentType.port) {
				hardwarePort.format
			}
			
			for (portConnector : hardwareComponentType.portConnector) {
				portConnector.format
			}
			
		}
		
		def dispatch void format(Node node, extension IFormattableDocument document) {
			val open = node.regionFor.keyword('{')
			val close = node.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : node.eClass.EAllAttributes) {
				
				val attrRegion = node.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : node.ownedComment) {
				comment.format
			}
			
			for (relationship : node.ownedRelationship) {
				relationship.format
			}
			
			for (hardwarePin : node.pin) {
				hardwarePin.format
			}
			
			for (hardwareComponentPrototype : node.part) {
				hardwareComponentPrototype.format
			}
			
			for (hardwareConnector : node.connector) {
				hardwareConnector.format
			}
			
			for (hardwarePort : node.port) {
				hardwarePort.format
			}
			
			for (portConnector : node.portConnector) {
				portConnector.format
			}
			
		}
		
		def dispatch void format(Sensor sensor, extension IFormattableDocument document) {
			val open = sensor.regionFor.keyword('{')
			val close = sensor.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : sensor.eClass.EAllAttributes) {
				
				val attrRegion = sensor.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : sensor.ownedComment) {
				comment.format
			}
			
			for (relationship : sensor.ownedRelationship) {
				relationship.format
			}
			
			for (hardwarePin : sensor.pin) {
				hardwarePin.format
			}
			
			for (hardwareComponentPrototype : sensor.part) {
				hardwareComponentPrototype.format
			}
			
			for (hardwareConnector : sensor.connector) {
				hardwareConnector.format
			}
			
			for (hardwarePort : sensor.port) {
				hardwarePort.format
			}
			
			for (portConnector : sensor.portConnector) {
				portConnector.format
			}
			
		}
		
		def dispatch void format(ArrayDatatype arrayDatatype, extension IFormattableDocument document) {
			val open = arrayDatatype.regionFor.keyword('{')
			val close = arrayDatatype.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : arrayDatatype.eClass.EAllAttributes) {
				
				val attrRegion = arrayDatatype.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : arrayDatatype.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(CompositeDatatype compositeDatatype, extension IFormattableDocument document) {
			val open = compositeDatatype.regionFor.keyword('{')
			val close = compositeDatatype.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : compositeDatatype.eClass.EAllAttributes) {
				
				val attrRegion = compositeDatatype.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : compositeDatatype.ownedComment) {
				comment.format
			}
			
			for (eADatatypePrototype : compositeDatatype.datatypePrototype) {
				eADatatypePrototype.format
			}
			
		}
		
		def dispatch void format(EABoolean eABoolean, extension IFormattableDocument document) {
			val open = eABoolean.regionFor.keyword('{')
			val close = eABoolean.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : eABoolean.eClass.EAllAttributes) {
				
				val attrRegion = eABoolean.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : eABoolean.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(EANumerical eANumerical, extension IFormattableDocument document) {
			val open = eANumerical.regionFor.keyword('{')
			val close = eANumerical.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : eANumerical.eClass.EAllAttributes) {
				
				val attrRegion = eANumerical.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : eANumerical.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(EAString eAString, extension IFormattableDocument document) {
			val open = eAString.regionFor.keyword('{')
			val close = eAString.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : eAString.eClass.EAllAttributes) {
				
				val attrRegion = eAString.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : eAString.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(Enumeration enumeration, extension IFormattableDocument document) {
			val open = enumeration.regionFor.keyword('{')
			val close = enumeration.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : enumeration.eClass.EAllAttributes) {
				
				val attrRegion = enumeration.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : enumeration.ownedComment) {
				comment.format
			}
			
			for (enumerationLiteral : enumeration.literal) {
				enumerationLiteral.format
			}
			
		}
		
		def dispatch void format(Quantity quantity, extension IFormattableDocument document) {
			val open = quantity.regionFor.keyword('{')
			val close = quantity.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : quantity.eClass.EAllAttributes) {
				
				val attrRegion = quantity.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : quantity.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(RangeableValueType rangeableValueType, extension IFormattableDocument document) {
			val open = rangeableValueType.regionFor.keyword('{')
			val close = rangeableValueType.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : rangeableValueType.eClass.EAllAttributes) {
				
				val attrRegion = rangeableValueType.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : rangeableValueType.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(Unit unit, extension IFormattableDocument document) {
			val open = unit.regionFor.keyword('{')
			val close = unit.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : unit.eClass.EAllAttributes) {
				
				val attrRegion = unit.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : unit.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(UserAttributeDefinition userAttributeDefinition, extension IFormattableDocument document) {
			val open = userAttributeDefinition.regionFor.keyword('{')
			val close = userAttributeDefinition.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : userAttributeDefinition.eClass.EAllAttributes) {
				
				val attrRegion = userAttributeDefinition.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : userAttributeDefinition.ownedComment) {
				comment.format
			}
			
			userAttributeDefinition.defaultValue.format
		}
		
		def dispatch void format(UserAttributedElement userAttributedElement, extension IFormattableDocument document) {
			val open = userAttributedElement.regionFor.keyword('{')
			val close = userAttributedElement.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : userAttributedElement.eClass.EAllAttributes) {
				
				val attrRegion = userAttributedElement.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : userAttributedElement.ownedComment) {
				comment.format
			}
			
			for (eAValue : userAttributedElement.uaValue) {
				eAValue.format
			}
			
		}
		
		def dispatch void format(UserElementType userElementType, extension IFormattableDocument document) {
			val open = userElementType.regionFor.keyword('{')
			val close = userElementType.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : userElementType.eClass.EAllAttributes) {
				
				val attrRegion = userElementType.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : userElementType.ownedComment) {
				comment.format
			}
			
			for (userAttributeDefinition : userElementType.uaDefinition) {
				userAttributeDefinition.format
			}
			
		}
		
		def dispatch void format(Allocation allocation, extension IFormattableDocument document) {
			val open = allocation.regionFor.keyword('{')
			val close = allocation.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : allocation.eClass.EAllAttributes) {
				
				val attrRegion = allocation.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : allocation.ownedComment) {
				comment.format
			}
			
			for (functionAllocation : allocation.functionAllocation) {
				functionAllocation.format
			}
			
		}
		
		def dispatch void format(DesignFunctionPrototype designFunctionPrototype, extension IFormattableDocument document) {
			val open = designFunctionPrototype.regionFor.keyword('{')
			val close = designFunctionPrototype.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : designFunctionPrototype.eClass.EAllAttributes) {
				
				val attrRegion = designFunctionPrototype.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : designFunctionPrototype.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(HardwareComponentPrototype hardwareComponentPrototype, extension IFormattableDocument document) {
			val open = hardwareComponentPrototype.regionFor.keyword('{')
			val close = hardwareComponentPrototype.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : hardwareComponentPrototype.eClass.EAllAttributes) {
				
				val attrRegion = hardwareComponentPrototype.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : hardwareComponentPrototype.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(Realization realization, extension IFormattableDocument document) {
			val open = realization.regionFor.keyword('{')
			val close = realization.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : realization.eClass.EAllAttributes) {
				
				val attrRegion = realization.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : realization.ownedComment) {
				comment.format
			}
			
			for (realization_realized : realization.realized) {
				realization_realized.format
			}
			
			for (realization_realizedBy : realization.realizedBy) {
				realization_realizedBy.format
			}
			
		}
		
		def dispatch void format(AnalysisFunctionPrototype analysisFunctionPrototype, extension IFormattableDocument document) {
			val open = analysisFunctionPrototype.regionFor.keyword('{')
			val close = analysisFunctionPrototype.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : analysisFunctionPrototype.eClass.EAllAttributes) {
				
				val attrRegion = analysisFunctionPrototype.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : analysisFunctionPrototype.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(FunctionAllocation functionAllocation, extension IFormattableDocument document) {
			val open = functionAllocation.regionFor.keyword('{')
			val close = functionAllocation.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : functionAllocation.eClass.EAllAttributes) {
				
				val attrRegion = functionAllocation.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : functionAllocation.ownedComment) {
				comment.format
			}
			
			functionAllocation.allocatedElement.format
			functionAllocation.target.format
		}
		
		def dispatch void format(FunctionClientServerPort functionClientServerPort, extension IFormattableDocument document) {
			val open = functionClientServerPort.regionFor.keyword('{')
			val close = functionClientServerPort.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : functionClientServerPort.eClass.EAllAttributes) {
				
				val attrRegion = functionClientServerPort.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : functionClientServerPort.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(FunctionConnector functionConnector, extension IFormattableDocument document) {
			val open = functionConnector.regionFor.keyword('{')
			val close = functionConnector.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : functionConnector.eClass.EAllAttributes) {
				
				val attrRegion = functionConnector.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : functionConnector.ownedComment) {
				comment.format
			}
			
			for (functionConnector_port : functionConnector.port) {
				functionConnector_port.format
			}
			
		}
		
		def dispatch void format(FunctionFlowPort functionFlowPort, extension IFormattableDocument document) {
			val open = functionFlowPort.regionFor.keyword('{')
			val close = functionFlowPort.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : functionFlowPort.eClass.EAllAttributes) {
				
				val attrRegion = functionFlowPort.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : functionFlowPort.ownedComment) {
				comment.format
			}
			
			functionFlowPort.defaultValue.format
		}
		
		def dispatch void format(FunctionPowerPort functionPowerPort, extension IFormattableDocument document) {
			val open = functionPowerPort.regionFor.keyword('{')
			val close = functionPowerPort.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : functionPowerPort.eClass.EAllAttributes) {
				
				val attrRegion = functionPowerPort.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : functionPowerPort.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(Operation operation, extension IFormattableDocument document) {
			val open = operation.regionFor.keyword('{')
			val close = operation.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : operation.eClass.EAllAttributes) {
				
				val attrRegion = operation.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : operation.ownedComment) {
				comment.format
			}
			
			for (eADatatypePrototype : operation.argument) {
				eADatatypePrototype.format
			}
			
		}
		
		def dispatch void format(PortGroup portGroup, extension IFormattableDocument document) {
			val open = portGroup.regionFor.keyword('{')
			val close = portGroup.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : portGroup.eClass.EAllAttributes) {
				
				val attrRegion = portGroup.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : portGroup.ownedComment) {
				comment.format
			}
			
			for (_portGroup : portGroup.portGroup) {
				_portGroup.format
			}
			
		}
		
		def dispatch void format(CommunicationHardwarePin communicationHardwarePin, extension IFormattableDocument document) {
			val open = communicationHardwarePin.regionFor.keyword('{')
			val close = communicationHardwarePin.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : communicationHardwarePin.eClass.EAllAttributes) {
				
				val attrRegion = communicationHardwarePin.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : communicationHardwarePin.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(HardwareConnector hardwareConnector, extension IFormattableDocument document) {
			val open = hardwareConnector.regionFor.keyword('{')
			val close = hardwareConnector.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : hardwareConnector.eClass.EAllAttributes) {
				
				val attrRegion = hardwareConnector.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : hardwareConnector.ownedComment) {
				comment.format
			}
			
			for (hardwareConnector_port : hardwareConnector.port) {
				hardwareConnector_port.format
			}
			
		}
		
		def dispatch void format(HardwarePort hardwarePort, extension IFormattableDocument document) {
			val open = hardwarePort.regionFor.keyword('{')
			val close = hardwarePort.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : hardwarePort.eClass.EAllAttributes) {
				
				val attrRegion = hardwarePort.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : hardwarePort.ownedComment) {
				comment.format
			}
			
			for (hardwarePin : hardwarePort.containedPin) {
				hardwarePin.format
			}
			
			for (_hardwarePort : hardwarePort.containedPort) {
				_hardwarePort.format
			}
			
		}
		
		def dispatch void format(HardwarePortConnector hardwarePortConnector, extension IFormattableDocument document) {
			val open = hardwarePortConnector.regionFor.keyword('{')
			val close = hardwarePortConnector.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : hardwarePortConnector.eClass.EAllAttributes) {
				
				val attrRegion = hardwarePortConnector.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : hardwarePortConnector.ownedComment) {
				comment.format
			}
			
			for (hardwarePortConnector_port : hardwarePortConnector.port) {
				hardwarePortConnector_port.format
			}
			
			for (hardwareConnector : hardwarePortConnector.connector) {
				hardwareConnector.format
			}
			
		}
		
		def dispatch void format(IOHardwarePin iOHardwarePin, extension IFormattableDocument document) {
			val open = iOHardwarePin.regionFor.keyword('{')
			val close = iOHardwarePin.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : iOHardwarePin.eClass.EAllAttributes) {
				
				val attrRegion = iOHardwarePin.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : iOHardwarePin.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(LogicalPortConnector logicalPortConnector, extension IFormattableDocument document) {
			val open = logicalPortConnector.regionFor.keyword('{')
			val close = logicalPortConnector.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : logicalPortConnector.eClass.EAllAttributes) {
				
				val attrRegion = logicalPortConnector.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : logicalPortConnector.ownedComment) {
				comment.format
			}
			
			for (hardwarePortConnector_port : logicalPortConnector.port) {
				hardwarePortConnector_port.format
			}
			
		}
		
		def dispatch void format(PowerHardwarePin powerHardwarePin, extension IFormattableDocument document) {
			val open = powerHardwarePin.regionFor.keyword('{')
			val close = powerHardwarePin.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : powerHardwarePin.eClass.EAllAttributes) {
				
				val attrRegion = powerHardwarePin.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : powerHardwarePin.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(EADatatypePrototype eADatatypePrototype, extension IFormattableDocument document) {
			val open = eADatatypePrototype.regionFor.keyword('{')
			val close = eADatatypePrototype.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : eADatatypePrototype.eClass.EAllAttributes) {
				
				val attrRegion = eADatatypePrototype.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : eADatatypePrototype.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(EnumerationLiteral enumerationLiteral, extension IFormattableDocument document) {
			val open = enumerationLiteral.regionFor.keyword('{')
			val close = enumerationLiteral.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : enumerationLiteral.eClass.EAllAttributes) {
				
				val attrRegion = enumerationLiteral.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (comment : enumerationLiteral.ownedComment) {
				comment.format
			}
			
		}
		
		def dispatch void format(EAArrayValue eAArrayValue, extension IFormattableDocument document) {
			val open = eAArrayValue.regionFor.keyword('{')
			val close = eAArrayValue.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : eAArrayValue.eClass.EAllAttributes) {
				
				val attrRegion = eAArrayValue.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (eAValue : eAArrayValue.value) {
				eAValue.format
			}
			
		}
		
		def dispatch void format(EACompositeValue eACompositeValue, extension IFormattableDocument document) {
			val open = eACompositeValue.regionFor.keyword('{')
			val close = eACompositeValue.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : eACompositeValue.eClass.EAllAttributes) {
				
				val attrRegion = eACompositeValue.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (eAValue : eACompositeValue.value) {
				eAValue.format
			}
			
		}
		
		def dispatch void format(EAExpression eAExpression, extension IFormattableDocument document) {
			val open = eAExpression.regionFor.keyword('{')
			val close = eAExpression.regionFor.keyword('}')
			
			open.append[newLine]
			close.prepend[newLine].append[newLine]
			
			for (attr : eAExpression.eClass.EAllAttributes) {
				
				val attrRegion = eAExpression.regionFor.keyword(attr.name)
				if (attrRegion !== null) {
					attrRegion.nextSemanticRegion.nextSemanticRegion.surround[noSpace].append[newLine]
				}
			}
			
			interior(
				open,
				close
			)[indent]
			
			for (eAValue : eAExpression.value) {
				eAValue.format
			}
			
		}
		

	}
