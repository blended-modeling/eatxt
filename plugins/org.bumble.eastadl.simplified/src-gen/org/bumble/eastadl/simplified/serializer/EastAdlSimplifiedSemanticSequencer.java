/*
 * generated by Xtext 2.25.0
 */
package org.bumble.eastadl.simplified.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.bumble.eastadl.simplified.services.EastAdlSimplifiedGrammarAccess;
import org.eclipse.eatop.eastadl22.Actuator;
import org.eclipse.eatop.eastadl22.Allocation;
import org.eclipse.eatop.eastadl22.AnalysisFunctionPrototype;
import org.eclipse.eatop.eastadl22.AnalysisFunctionType;
import org.eclipse.eatop.eastadl22.ArrayDatatype;
import org.eclipse.eatop.eastadl22.BasicSoftwareFunctionType;
import org.eclipse.eatop.eastadl22.Comment;
import org.eclipse.eatop.eastadl22.CommunicationHardwarePin;
import org.eclipse.eatop.eastadl22.CompositeDatatype;
import org.eclipse.eatop.eastadl22.DesignFunctionPrototype;
import org.eclipse.eatop.eastadl22.DesignFunctionType;
import org.eclipse.eatop.eastadl22.DesignLevel;
import org.eclipse.eatop.eastadl22.EAArrayValue;
import org.eclipse.eatop.eastadl22.EABoolean;
import org.eclipse.eatop.eastadl22.EABooleanValue;
import org.eclipse.eatop.eastadl22.EACompositeValue;
import org.eclipse.eatop.eastadl22.EADatatypePrototype;
import org.eclipse.eatop.eastadl22.EAEnumerationValue;
import org.eclipse.eatop.eastadl22.EAExpression;
import org.eclipse.eatop.eastadl22.EANumerical;
import org.eclipse.eatop.eastadl22.EANumericalValue;
import org.eclipse.eatop.eastadl22.EAPackage;
import org.eclipse.eatop.eastadl22.EAString;
import org.eclipse.eatop.eastadl22.EAStringValue;
import org.eclipse.eatop.eastadl22.EAXML;
import org.eclipse.eatop.eastadl22.Eastadl22Package;
import org.eclipse.eatop.eastadl22.ElectricalComponent;
import org.eclipse.eatop.eastadl22.Enumeration;
import org.eclipse.eatop.eastadl22.EnumerationLiteral;
import org.eclipse.eatop.eastadl22.FunctionAllocation;
import org.eclipse.eatop.eastadl22.FunctionAllocation_allocatedElement;
import org.eclipse.eatop.eastadl22.FunctionAllocation_target;
import org.eclipse.eatop.eastadl22.FunctionClientServerInterface;
import org.eclipse.eatop.eastadl22.FunctionClientServerPort;
import org.eclipse.eatop.eastadl22.FunctionConnector;
import org.eclipse.eatop.eastadl22.FunctionConnector_port;
import org.eclipse.eatop.eastadl22.FunctionFlowPort;
import org.eclipse.eatop.eastadl22.FunctionPowerPort;
import org.eclipse.eatop.eastadl22.FunctionalDevice;
import org.eclipse.eatop.eastadl22.HardwareComponentPrototype;
import org.eclipse.eatop.eastadl22.HardwareComponentType;
import org.eclipse.eatop.eastadl22.HardwareConnector;
import org.eclipse.eatop.eastadl22.HardwareConnector_port;
import org.eclipse.eatop.eastadl22.HardwareFunctionType;
import org.eclipse.eatop.eastadl22.HardwarePort;
import org.eclipse.eatop.eastadl22.HardwarePortConnector;
import org.eclipse.eatop.eastadl22.HardwarePortConnector_port;
import org.eclipse.eatop.eastadl22.IOHardwarePin;
import org.eclipse.eatop.eastadl22.LocalDeviceManager;
import org.eclipse.eatop.eastadl22.LogicalPortConnector;
import org.eclipse.eatop.eastadl22.Node;
import org.eclipse.eatop.eastadl22.Operation;
import org.eclipse.eatop.eastadl22.PortGroup;
import org.eclipse.eatop.eastadl22.PowerHardwarePin;
import org.eclipse.eatop.eastadl22.Quantity;
import org.eclipse.eatop.eastadl22.RangeableValueType;
import org.eclipse.eatop.eastadl22.Rationale;
import org.eclipse.eatop.eastadl22.Realization;
import org.eclipse.eatop.eastadl22.Realization_realized;
import org.eclipse.eatop.eastadl22.Realization_realizedBy;
import org.eclipse.eatop.eastadl22.Sensor;
import org.eclipse.eatop.eastadl22.Unit;
import org.eclipse.eatop.eastadl22.UserAttributeDefinition;
import org.eclipse.eatop.eastadl22.UserAttributedElement;
import org.eclipse.eatop.eastadl22.UserElementType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;
import org.eclipse.xtext.common.types.JvmInnerTypeReference;
import org.eclipse.xtext.common.types.JvmLowerBound;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmUpperBound;
import org.eclipse.xtext.common.types.JvmWildcardTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.xbase.XAssignment;
import org.eclipse.xtext.xbase.XBasicForLoopExpression;
import org.eclipse.xtext.xbase.XBinaryOperation;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XBooleanLiteral;
import org.eclipse.xtext.xbase.XCasePart;
import org.eclipse.xtext.xbase.XCastedExpression;
import org.eclipse.xtext.xbase.XCatchClause;
import org.eclipse.xtext.xbase.XClosure;
import org.eclipse.xtext.xbase.XConstructorCall;
import org.eclipse.xtext.xbase.XDoWhileExpression;
import org.eclipse.xtext.xbase.XFeatureCall;
import org.eclipse.xtext.xbase.XForLoopExpression;
import org.eclipse.xtext.xbase.XIfExpression;
import org.eclipse.xtext.xbase.XInstanceOfExpression;
import org.eclipse.xtext.xbase.XListLiteral;
import org.eclipse.xtext.xbase.XMemberFeatureCall;
import org.eclipse.xtext.xbase.XNullLiteral;
import org.eclipse.xtext.xbase.XNumberLiteral;
import org.eclipse.xtext.xbase.XPostfixOperation;
import org.eclipse.xtext.xbase.XReturnExpression;
import org.eclipse.xtext.xbase.XSetLiteral;
import org.eclipse.xtext.xbase.XStringLiteral;
import org.eclipse.xtext.xbase.XSwitchExpression;
import org.eclipse.xtext.xbase.XSynchronizedExpression;
import org.eclipse.xtext.xbase.XThrowExpression;
import org.eclipse.xtext.xbase.XTryCatchFinallyExpression;
import org.eclipse.xtext.xbase.XTypeLiteral;
import org.eclipse.xtext.xbase.XUnaryOperation;
import org.eclipse.xtext.xbase.XVariableDeclaration;
import org.eclipse.xtext.xbase.XWhileExpression;
import org.eclipse.xtext.xbase.XbasePackage;
import org.eclipse.xtext.xbase.serializer.XbaseSemanticSequencer;
import org.eclipse.xtext.xtype.XFunctionTypeRef;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;

@SuppressWarnings("all")
public class EastAdlSimplifiedSemanticSequencer extends XbaseSemanticSequencer {

	@Inject
	private EastAdlSimplifiedGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Eastadl22Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Eastadl22Package.ACTUATOR:
				sequence_Actuator(context, (Actuator) semanticObject); 
				return; 
			case Eastadl22Package.ALLOCATION:
				sequence_Allocation(context, (Allocation) semanticObject); 
				return; 
			case Eastadl22Package.ANALYSIS_FUNCTION_PROTOTYPE:
				sequence_AnalysisFunctionPrototype(context, (AnalysisFunctionPrototype) semanticObject); 
				return; 
			case Eastadl22Package.ANALYSIS_FUNCTION_TYPE:
				sequence_AnalysisFunctionType_Impl(context, (AnalysisFunctionType) semanticObject); 
				return; 
			case Eastadl22Package.ARRAY_DATATYPE:
				sequence_ArrayDatatype(context, (ArrayDatatype) semanticObject); 
				return; 
			case Eastadl22Package.BASIC_SOFTWARE_FUNCTION_TYPE:
				sequence_BasicSoftwareFunctionType(context, (BasicSoftwareFunctionType) semanticObject); 
				return; 
			case Eastadl22Package.COMMENT:
				sequence_Comment_Impl(context, (Comment) semanticObject); 
				return; 
			case Eastadl22Package.COMMUNICATION_HARDWARE_PIN:
				sequence_CommunicationHardwarePin(context, (CommunicationHardwarePin) semanticObject); 
				return; 
			case Eastadl22Package.COMPOSITE_DATATYPE:
				sequence_CompositeDatatype(context, (CompositeDatatype) semanticObject); 
				return; 
			case Eastadl22Package.DESIGN_FUNCTION_PROTOTYPE:
				sequence_DesignFunctionPrototype(context, (DesignFunctionPrototype) semanticObject); 
				return; 
			case Eastadl22Package.DESIGN_FUNCTION_TYPE:
				sequence_DesignFunctionType_Impl(context, (DesignFunctionType) semanticObject); 
				return; 
			case Eastadl22Package.DESIGN_LEVEL:
				sequence_DesignLevel(context, (DesignLevel) semanticObject); 
				return; 
			case Eastadl22Package.EA_ARRAY_VALUE:
				sequence_EAArrayValue(context, (EAArrayValue) semanticObject); 
				return; 
			case Eastadl22Package.EA_BOOLEAN:
				sequence_EABoolean(context, (EABoolean) semanticObject); 
				return; 
			case Eastadl22Package.EA_BOOLEAN_VALUE:
				sequence_EABooleanValue(context, (EABooleanValue) semanticObject); 
				return; 
			case Eastadl22Package.EA_COMPOSITE_VALUE:
				sequence_EACompositeValue(context, (EACompositeValue) semanticObject); 
				return; 
			case Eastadl22Package.EA_DATATYPE_PROTOTYPE:
				sequence_EADatatypePrototype(context, (EADatatypePrototype) semanticObject); 
				return; 
			case Eastadl22Package.EA_ENUMERATION_VALUE:
				sequence_EAEnumerationValue(context, (EAEnumerationValue) semanticObject); 
				return; 
			case Eastadl22Package.EA_EXPRESSION:
				sequence_EAExpression(context, (EAExpression) semanticObject); 
				return; 
			case Eastadl22Package.EA_NUMERICAL:
				sequence_EANumerical(context, (EANumerical) semanticObject); 
				return; 
			case Eastadl22Package.EA_NUMERICAL_VALUE:
				sequence_EANumericalValue(context, (EANumericalValue) semanticObject); 
				return; 
			case Eastadl22Package.EA_PACKAGE:
				sequence_EAPackage(context, (EAPackage) semanticObject); 
				return; 
			case Eastadl22Package.EA_STRING:
				sequence_EAString(context, (EAString) semanticObject); 
				return; 
			case Eastadl22Package.EA_STRING_VALUE:
				sequence_EAStringValue(context, (EAStringValue) semanticObject); 
				return; 
			case Eastadl22Package.EAXML:
				sequence_EAXML(context, (EAXML) semanticObject); 
				return; 
			case Eastadl22Package.ELECTRICAL_COMPONENT:
				sequence_ElectricalComponent(context, (ElectricalComponent) semanticObject); 
				return; 
			case Eastadl22Package.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case Eastadl22Package.ENUMERATION_LITERAL:
				sequence_EnumerationLiteral(context, (EnumerationLiteral) semanticObject); 
				return; 
			case Eastadl22Package.FUNCTION_ALLOCATION:
				sequence_FunctionAllocation(context, (FunctionAllocation) semanticObject); 
				return; 
			case Eastadl22Package.FUNCTION_ALLOCATION_ALLOCATED_ELEMENT:
				sequence_FunctionAllocation_allocatedElement(context, (FunctionAllocation_allocatedElement) semanticObject); 
				return; 
			case Eastadl22Package.FUNCTION_ALLOCATION_TARGET:
				sequence_FunctionAllocation_target(context, (FunctionAllocation_target) semanticObject); 
				return; 
			case Eastadl22Package.FUNCTION_CLIENT_SERVER_INTERFACE:
				sequence_FunctionClientServerInterface(context, (FunctionClientServerInterface) semanticObject); 
				return; 
			case Eastadl22Package.FUNCTION_CLIENT_SERVER_PORT:
				sequence_FunctionClientServerPort(context, (FunctionClientServerPort) semanticObject); 
				return; 
			case Eastadl22Package.FUNCTION_CONNECTOR:
				sequence_FunctionConnector(context, (FunctionConnector) semanticObject); 
				return; 
			case Eastadl22Package.FUNCTION_CONNECTOR_PORT:
				sequence_FunctionConnector_port(context, (FunctionConnector_port) semanticObject); 
				return; 
			case Eastadl22Package.FUNCTION_FLOW_PORT:
				sequence_FunctionFlowPort(context, (FunctionFlowPort) semanticObject); 
				return; 
			case Eastadl22Package.FUNCTION_POWER_PORT:
				sequence_FunctionPowerPort(context, (FunctionPowerPort) semanticObject); 
				return; 
			case Eastadl22Package.FUNCTIONAL_DEVICE:
				sequence_FunctionalDevice(context, (FunctionalDevice) semanticObject); 
				return; 
			case Eastadl22Package.HARDWARE_COMPONENT_PROTOTYPE:
				sequence_HardwareComponentPrototype(context, (HardwareComponentPrototype) semanticObject); 
				return; 
			case Eastadl22Package.HARDWARE_COMPONENT_TYPE:
				sequence_HardwareComponentType_Impl(context, (HardwareComponentType) semanticObject); 
				return; 
			case Eastadl22Package.HARDWARE_CONNECTOR:
				sequence_HardwareConnector(context, (HardwareConnector) semanticObject); 
				return; 
			case Eastadl22Package.HARDWARE_CONNECTOR_PORT:
				sequence_HardwareConnector_port(context, (HardwareConnector_port) semanticObject); 
				return; 
			case Eastadl22Package.HARDWARE_FUNCTION_TYPE:
				sequence_HardwareFunctionType(context, (HardwareFunctionType) semanticObject); 
				return; 
			case Eastadl22Package.HARDWARE_PORT:
				sequence_HardwarePort(context, (HardwarePort) semanticObject); 
				return; 
			case Eastadl22Package.HARDWARE_PORT_CONNECTOR:
				sequence_HardwarePortConnector(context, (HardwarePortConnector) semanticObject); 
				return; 
			case Eastadl22Package.HARDWARE_PORT_CONNECTOR_PORT:
				sequence_HardwarePortConnector_port(context, (HardwarePortConnector_port) semanticObject); 
				return; 
			case Eastadl22Package.IO_HARDWARE_PIN:
				sequence_IOHardwarePin(context, (IOHardwarePin) semanticObject); 
				return; 
			case Eastadl22Package.LOCAL_DEVICE_MANAGER:
				sequence_LocalDeviceManager(context, (LocalDeviceManager) semanticObject); 
				return; 
			case Eastadl22Package.LOGICAL_PORT_CONNECTOR:
				sequence_LogicalPortConnector(context, (LogicalPortConnector) semanticObject); 
				return; 
			case Eastadl22Package.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case Eastadl22Package.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case Eastadl22Package.PORT_GROUP:
				sequence_PortGroup(context, (PortGroup) semanticObject); 
				return; 
			case Eastadl22Package.POWER_HARDWARE_PIN:
				sequence_PowerHardwarePin(context, (PowerHardwarePin) semanticObject); 
				return; 
			case Eastadl22Package.QUANTITY:
				sequence_Quantity(context, (Quantity) semanticObject); 
				return; 
			case Eastadl22Package.RANGEABLE_VALUE_TYPE:
				sequence_RangeableValueType(context, (RangeableValueType) semanticObject); 
				return; 
			case Eastadl22Package.RATIONALE:
				sequence_Rationale(context, (Rationale) semanticObject); 
				return; 
			case Eastadl22Package.REALIZATION:
				sequence_Realization(context, (Realization) semanticObject); 
				return; 
			case Eastadl22Package.REALIZATION_REALIZED:
				sequence_Realization_realized(context, (Realization_realized) semanticObject); 
				return; 
			case Eastadl22Package.REALIZATION_REALIZED_BY:
				sequence_Realization_realizedBy(context, (Realization_realizedBy) semanticObject); 
				return; 
			case Eastadl22Package.SENSOR:
				sequence_Sensor(context, (Sensor) semanticObject); 
				return; 
			case Eastadl22Package.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case Eastadl22Package.USER_ATTRIBUTE_DEFINITION:
				sequence_UserAttributeDefinition(context, (UserAttributeDefinition) semanticObject); 
				return; 
			case Eastadl22Package.USER_ATTRIBUTED_ELEMENT:
				sequence_UserAttributedElement(context, (UserAttributedElement) semanticObject); 
				return; 
			case Eastadl22Package.USER_ELEMENT_TYPE:
				sequence_UserElementType(context, (UserElementType) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.JVM_FORMAL_PARAMETER:
				if (rule == grammarAccess.getFullJvmFormalParameterRule()) {
					sequence_FullJvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmFormalParameterRule()) {
					sequence_JvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_GENERIC_ARRAY_TYPE_REFERENCE:
				sequence_JvmTypeReference(context, (JvmGenericArrayTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_INNER_TYPE_REFERENCE:
				sequence_JvmParameterizedTypeReference(context, (JvmInnerTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_LOWER_BOUND:
				if (rule == grammarAccess.getJvmLowerBoundAndedRule()) {
					sequence_JvmLowerBoundAnded(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmLowerBoundRule()) {
					sequence_JvmLowerBound(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_PARAMETERIZED_TYPE_REFERENCE:
				if (action == grammarAccess.getJvmParameterizedTypeReferenceAccess().getJvmInnerTypeReferenceOuterAction_1_4_0_0_0()) {
					sequence_JvmParameterizedTypeReference_JvmInnerTypeReference_1_4_0_0_0(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmTypeReferenceRule()
						|| action == grammarAccess.getJvmTypeReferenceAccess().getJvmGenericArrayTypeReferenceComponentTypeAction_0_1_0_0()
						|| rule == grammarAccess.getJvmParameterizedTypeReferenceRule()
						|| rule == grammarAccess.getJvmArgumentTypeReferenceRule()) {
					sequence_JvmParameterizedTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_TYPE_PARAMETER:
				sequence_JvmTypeParameter(context, (JvmTypeParameter) semanticObject); 
				return; 
			case TypesPackage.JVM_UPPER_BOUND:
				if (rule == grammarAccess.getJvmUpperBoundAndedRule()) {
					sequence_JvmUpperBoundAnded(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmUpperBoundRule()) {
					sequence_JvmUpperBound(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_WILDCARD_TYPE_REFERENCE:
				sequence_JvmWildcardTypeReference(context, (JvmWildcardTypeReference) semanticObject); 
				return; 
			}
		else if (epackage == XbasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XbasePackage.XASSIGNMENT:
				sequence_XAssignment_XMemberFeatureCall(context, (XAssignment) semanticObject); 
				return; 
			case XbasePackage.XBASIC_FOR_LOOP_EXPRESSION:
				sequence_XBasicForLoopExpression(context, (XBasicForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XBINARY_OPERATION:
				sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XOtherOperatorExpression_XRelationalExpression(context, (XBinaryOperation) semanticObject); 
				return; 
			case XbasePackage.XBLOCK_EXPRESSION:
				if (rule == grammarAccess.getXBlockExpressionRule()
						|| rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XBlockExpression(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXExpressionInClosureRule()) {
					sequence_XExpressionInClosure(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XBOOLEAN_LITERAL:
				sequence_XBooleanLiteral(context, (XBooleanLiteral) semanticObject); 
				return; 
			case XbasePackage.XCASE_PART:
				sequence_XCasePart(context, (XCasePart) semanticObject); 
				return; 
			case XbasePackage.XCASTED_EXPRESSION:
				sequence_XCastedExpression(context, (XCastedExpression) semanticObject); 
				return; 
			case XbasePackage.XCATCH_CLAUSE:
				sequence_XCatchClause(context, (XCatchClause) semanticObject); 
				return; 
			case XbasePackage.XCLOSURE:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXLiteralRule()
						|| rule == grammarAccess.getXClosureRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXShortClosureRule()) {
					sequence_XShortClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XCONSTRUCTOR_CALL:
				sequence_XConstructorCall(context, (XConstructorCall) semanticObject); 
				return; 
			case XbasePackage.XDO_WHILE_EXPRESSION:
				sequence_XDoWhileExpression(context, (XDoWhileExpression) semanticObject); 
				return; 
			case XbasePackage.XFEATURE_CALL:
				sequence_XFeatureCall(context, (XFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XFOR_LOOP_EXPRESSION:
				sequence_XForLoopExpression(context, (XForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XIF_EXPRESSION:
				sequence_XIfExpression(context, (XIfExpression) semanticObject); 
				return; 
			case XbasePackage.XINSTANCE_OF_EXPRESSION:
				sequence_XRelationalExpression(context, (XInstanceOfExpression) semanticObject); 
				return; 
			case XbasePackage.XLIST_LITERAL:
				sequence_XListLiteral(context, (XListLiteral) semanticObject); 
				return; 
			case XbasePackage.XMEMBER_FEATURE_CALL:
				sequence_XMemberFeatureCall(context, (XMemberFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XNULL_LITERAL:
				sequence_XNullLiteral(context, (XNullLiteral) semanticObject); 
				return; 
			case XbasePackage.XNUMBER_LITERAL:
				sequence_XNumberLiteral(context, (XNumberLiteral) semanticObject); 
				return; 
			case XbasePackage.XPOSTFIX_OPERATION:
				sequence_XPostfixOperation(context, (XPostfixOperation) semanticObject); 
				return; 
			case XbasePackage.XRETURN_EXPRESSION:
				sequence_XReturnExpression(context, (XReturnExpression) semanticObject); 
				return; 
			case XbasePackage.XSET_LITERAL:
				sequence_XSetLiteral(context, (XSetLiteral) semanticObject); 
				return; 
			case XbasePackage.XSTRING_LITERAL:
				sequence_XStringLiteral(context, (XStringLiteral) semanticObject); 
				return; 
			case XbasePackage.XSWITCH_EXPRESSION:
				sequence_XSwitchExpression(context, (XSwitchExpression) semanticObject); 
				return; 
			case XbasePackage.XSYNCHRONIZED_EXPRESSION:
				sequence_XSynchronizedExpression(context, (XSynchronizedExpression) semanticObject); 
				return; 
			case XbasePackage.XTHROW_EXPRESSION:
				sequence_XThrowExpression(context, (XThrowExpression) semanticObject); 
				return; 
			case XbasePackage.XTRY_CATCH_FINALLY_EXPRESSION:
				sequence_XTryCatchFinallyExpression(context, (XTryCatchFinallyExpression) semanticObject); 
				return; 
			case XbasePackage.XTYPE_LITERAL:
				sequence_XTypeLiteral(context, (XTypeLiteral) semanticObject); 
				return; 
			case XbasePackage.XUNARY_OPERATION:
				sequence_XUnaryOperation(context, (XUnaryOperation) semanticObject); 
				return; 
			case XbasePackage.XVARIABLE_DECLARATION:
				sequence_XVariableDeclaration(context, (XVariableDeclaration) semanticObject); 
				return; 
			case XbasePackage.XWHILE_EXPRESSION:
				sequence_XWhileExpression(context, (XWhileExpression) semanticObject); 
				return; 
			}
		else if (epackage == XtypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XtypePackage.XFUNCTION_TYPE_REF:
				sequence_XFunctionTypeRef(context, (XFunctionTypeRef) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_DECLARATION:
				sequence_XImportDeclaration(context, (XImportDeclaration) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_SECTION:
				sequence_XImportSection(context, (XImportSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns Actuator
	 *     HardwareComponentType returns Actuator
	 *     Identifiable returns Actuator
	 *     EAElement returns Actuator
	 *     Actuator returns Actuator
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (pin+=HardwarePin pin+=HardwarePin*)? 
	 *         (part+=HardwareComponentPrototype part+=HardwareComponentPrototype*)? 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)? 
	 *         (port+=HardwarePort port+=HardwarePort*)? 
	 *         (portConnector+=PortConnector portConnector+=PortConnector*)?
	 *     )
	 */
	protected void sequence_Actuator(ISerializationContext context, Actuator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns Allocation
	 *     EAElement returns Allocation
	 *     Allocation returns Allocation
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (functionAllocation+=FunctionAllocation functionAllocation+=FunctionAllocation*)?
	 *     )
	 */
	protected void sequence_Allocation(ISerializationContext context, Allocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns AnalysisFunctionPrototype
	 *     EAElement returns AnalysisFunctionPrototype
	 *     FunctionPrototype returns AnalysisFunctionPrototype
	 *     AnalysisFunctionPrototype returns AnalysisFunctionPrototype
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         type=[AnalysisFunctionType|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_AnalysisFunctionPrototype(ISerializationContext context, AnalysisFunctionPrototype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns AnalysisFunctionType
	 *     Identifiable returns AnalysisFunctionType
	 *     EAElement returns AnalysisFunctionType
	 *     AnalysisFunctionType returns AnalysisFunctionType
	 *     AnalysisFunctionType_Impl returns AnalysisFunctionType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isElementary=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)? 
	 *         (connector+=FunctionConnector connector+=FunctionConnector*)? 
	 *         (port+=FunctionPort port+=FunctionPort*)? 
	 *         (part+=AnalysisFunctionPrototype part+=AnalysisFunctionPrototype*)?
	 *     )
	 */
	protected void sequence_AnalysisFunctionType_Impl(ISerializationContext context, AnalysisFunctionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns ArrayDatatype
	 *     TraceableSpecification returns ArrayDatatype
	 *     EADatatype returns ArrayDatatype
	 *     Identifiable returns ArrayDatatype
	 *     EAElement returns ArrayDatatype
	 *     ArrayDatatype returns ArrayDatatype
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         uri=String0? 
	 *         maxLength=Integer? 
	 *         minLength=Integer? 
	 *         elementType=[EADatatype|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_ArrayDatatype(ISerializationContext context, ArrayDatatype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns BasicSoftwareFunctionType
	 *     Identifiable returns BasicSoftwareFunctionType
	 *     DesignFunctionType returns BasicSoftwareFunctionType
	 *     EAElement returns BasicSoftwareFunctionType
	 *     BasicSoftwareFunctionType returns BasicSoftwareFunctionType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isElementary=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)? 
	 *         (connector+=FunctionConnector connector+=FunctionConnector*)? 
	 *         (port+=FunctionPort port+=FunctionPort*)? 
	 *         (part+=DesignFunctionPrototype part+=DesignFunctionPrototype*)?
	 *     )
	 */
	protected void sequence_BasicSoftwareFunctionType(ISerializationContext context, BasicSoftwareFunctionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Comment returns Comment
	 *     Comment_Impl returns Comment
	 *
	 * Constraint:
	 *     body=String0
	 */
	protected void sequence_Comment_Impl(ISerializationContext context, Comment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Eastadl22Package.eINSTANCE.getComment_Body()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl22Package.eINSTANCE.getComment_Body()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComment_ImplAccess().getBodyString0ParserRuleCall_1_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     HardwarePin returns CommunicationHardwarePin
	 *     Identifiable returns CommunicationHardwarePin
	 *     EAElement returns CommunicationHardwarePin
	 *     AllocationTarget returns CommunicationHardwarePin
	 *     CommunicationHardwarePin returns CommunicationHardwarePin
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         direction=EADirectionKind? 
	 *         isGround=Boolean? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_CommunicationHardwarePin(ISerializationContext context, CommunicationHardwarePin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns CompositeDatatype
	 *     TraceableSpecification returns CompositeDatatype
	 *     EADatatype returns CompositeDatatype
	 *     Identifiable returns CompositeDatatype
	 *     EAElement returns CompositeDatatype
	 *     CompositeDatatype returns CompositeDatatype
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         uri=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         datatypePrototype+=EADatatypePrototype 
	 *         datatypePrototype+=EADatatypePrototype*
	 *     )
	 */
	protected void sequence_CompositeDatatype(ISerializationContext context, CompositeDatatype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns DesignFunctionPrototype
	 *     EAElement returns DesignFunctionPrototype
	 *     AllocateableElement returns DesignFunctionPrototype
	 *     FunctionPrototype returns DesignFunctionPrototype
	 *     DesignFunctionPrototype returns DesignFunctionPrototype
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         type=[DesignFunctionType|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_DesignFunctionPrototype(ISerializationContext context, DesignFunctionPrototype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns DesignFunctionType
	 *     Identifiable returns DesignFunctionType
	 *     DesignFunctionType returns DesignFunctionType
	 *     EAElement returns DesignFunctionType
	 *     DesignFunctionType_Impl returns DesignFunctionType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isElementary=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)? 
	 *         (connector+=FunctionConnector connector+=FunctionConnector*)? 
	 *         (port+=FunctionPort port+=FunctionPort*)? 
	 *         (part+=DesignFunctionPrototype part+=DesignFunctionPrototype*)?
	 *     )
	 */
	protected void sequence_DesignFunctionType_Impl(ISerializationContext context, DesignFunctionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns DesignLevel
	 *     Identifiable returns DesignLevel
	 *     EAElement returns DesignLevel
	 *     DesignLevel returns DesignLevel
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (allocation+=Allocation allocation+=Allocation*)? 
	 *         functionalDesignArchitecture=DesignFunctionPrototype? 
	 *         hardwareDesignArchitecture=HardwareComponentPrototype?
	 *     )
	 */
	protected void sequence_DesignLevel(ISerializationContext context, DesignLevel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EAArrayValue
	 *     EAArrayValue returns EAArrayValue
	 *
	 * Constraint:
	 *     (type=[EADatatype|EString] (value+=EAValue value+=EAValue*)?)
	 */
	protected void sequence_EAArrayValue(ISerializationContext context, EAArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EABooleanValue
	 *     EABooleanValue returns EABooleanValue
	 *
	 * Constraint:
	 *     (value=Boolean type=[EADatatype|EString])
	 */
	protected void sequence_EABooleanValue(ISerializationContext context, EABooleanValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Eastadl22Package.eINSTANCE.getEABooleanValue_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl22Package.eINSTANCE.getEABooleanValue_Value()));
			if (transientValues.isValueTransient(semanticObject, Eastadl22Package.eINSTANCE.getEAValue_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl22Package.eINSTANCE.getEAValue_Type()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEABooleanValueAccess().getValueBooleanParserRuleCall_1_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEABooleanValueAccess().getTypeEADatatypeEStringParserRuleCall_1_4_0_1(), semanticObject.eGet(Eastadl22Package.eINSTANCE.getEAValue_Type(), false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns EABoolean
	 *     TraceableSpecification returns EABoolean
	 *     EADatatype returns EABoolean
	 *     Identifiable returns EABoolean
	 *     EAElement returns EABoolean
	 *     EABoolean returns EABoolean
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         uri=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_EABoolean(ISerializationContext context, EABoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EACompositeValue
	 *     EACompositeValue returns EACompositeValue
	 *
	 * Constraint:
	 *     (type=[EADatatype|EString] value+=EAValue value+=EAValue*)
	 */
	protected void sequence_EACompositeValue(ISerializationContext context, EACompositeValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns EADatatypePrototype
	 *     EAElement returns EADatatypePrototype
	 *     EADatatypePrototype returns EADatatypePrototype
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         type=[EADatatype|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_EADatatypePrototype(ISerializationContext context, EADatatypePrototype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EAEnumerationValue
	 *     EAEnumerationValue returns EAEnumerationValue
	 *
	 * Constraint:
	 *     (type=[EADatatype|EString] value+=[EnumerationLiteral|EString] value+=[EnumerationLiteral|EString]*)
	 */
	protected void sequence_EAEnumerationValue(ISerializationContext context, EAEnumerationValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EAExpression
	 *     EAExpression returns EAExpression
	 *
	 * Constraint:
	 *     (type=[EADatatype|EString] (value+=EAValue value+=EAValue*)?)
	 */
	protected void sequence_EAExpression(ISerializationContext context, EAExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EANumericalValue
	 *     EANumericalValue returns EANumericalValue
	 *
	 * Constraint:
	 *     (value=Numerical type=[EADatatype|EString])
	 */
	protected void sequence_EANumericalValue(ISerializationContext context, EANumericalValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Eastadl22Package.eINSTANCE.getEANumericalValue_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl22Package.eINSTANCE.getEANumericalValue_Value()));
			if (transientValues.isValueTransient(semanticObject, Eastadl22Package.eINSTANCE.getEAValue_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl22Package.eINSTANCE.getEAValue_Type()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEANumericalValueAccess().getValueNumericalParserRuleCall_1_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEANumericalValueAccess().getTypeEADatatypeEStringParserRuleCall_1_4_0_1(), semanticObject.eGet(Eastadl22Package.eINSTANCE.getEAValue_Type(), false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns EANumerical
	 *     TraceableSpecification returns EANumerical
	 *     EADatatype returns EANumerical
	 *     Identifiable returns EANumerical
	 *     EAElement returns EANumerical
	 *     EANumerical returns EANumerical
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         uri=String0? 
	 *         max=Numerical? 
	 *         min=Numerical? 
	 *         unit=[Unit|EString]? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_EANumerical(ISerializationContext context, EANumerical semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns EAPackage
	 *     EAElement returns EAPackage
	 *     EAPackage returns EAPackage
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String1? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (subPackage+=EAPackage subPackage+=EAPackage*)? 
	 *         (element+=EAPackageableElement element+=EAPackageableElement*)?
	 *     )
	 */
	protected void sequence_EAPackage(ISerializationContext context, EAPackage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAValue returns EAStringValue
	 *     EAStringValue returns EAStringValue
	 *
	 * Constraint:
	 *     (value=String0 type=[EADatatype|EString])
	 */
	protected void sequence_EAStringValue(ISerializationContext context, EAStringValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Eastadl22Package.eINSTANCE.getEAStringValue_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl22Package.eINSTANCE.getEAStringValue_Value()));
			if (transientValues.isValueTransient(semanticObject, Eastadl22Package.eINSTANCE.getEAValue_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl22Package.eINSTANCE.getEAValue_Type()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEAStringValueAccess().getValueString0ParserRuleCall_1_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEAStringValueAccess().getTypeEADatatypeEStringParserRuleCall_1_4_0_1(), semanticObject.eGet(Eastadl22Package.eINSTANCE.getEAValue_Type(), false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns EAString
	 *     TraceableSpecification returns EAString
	 *     EADatatype returns EAString
	 *     Identifiable returns EAString
	 *     EAElement returns EAString
	 *     EAString returns EAString
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         uri=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_EAString(ISerializationContext context, EAString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAXML returns EAXML
	 *
	 * Constraint:
	 *     (topLevelPackage+=EAPackage topLevelPackage+=EAPackage*)?
	 */
	protected void sequence_EAXML(ISerializationContext context, EAXML semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns ElectricalComponent
	 *     HardwareComponentType returns ElectricalComponent
	 *     Identifiable returns ElectricalComponent
	 *     EAElement returns ElectricalComponent
	 *     ElectricalComponent returns ElectricalComponent
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isActive=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (pin+=HardwarePin pin+=HardwarePin*)? 
	 *         (part+=HardwareComponentPrototype part+=HardwareComponentPrototype*)? 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)? 
	 *         (port+=HardwarePort port+=HardwarePort*)? 
	 *         (portConnector+=PortConnector portConnector+=PortConnector*)?
	 *     )
	 */
	protected void sequence_ElectricalComponent(ISerializationContext context, ElectricalComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns EnumerationLiteral
	 *     EAElement returns EnumerationLiteral
	 *     EnumerationLiteral returns EnumerationLiteral
	 *
	 * Constraint:
	 *     (shortName=Identifier category=Identifier? uuid=String0? name=String0? (ownedComment+=Comment ownedComment+=Comment*)?)
	 */
	protected void sequence_EnumerationLiteral(ISerializationContext context, EnumerationLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns Enumeration
	 *     TraceableSpecification returns Enumeration
	 *     EADatatype returns Enumeration
	 *     Identifiable returns Enumeration
	 *     EAElement returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         uri=String0? 
	 *         isMultiValued=Boolean 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         literal+=EnumerationLiteral 
	 *         literal+=EnumerationLiteral*
	 *     )
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns FunctionAllocation
	 *     EAElement returns FunctionAllocation
	 *     FunctionAllocation returns FunctionAllocation
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         allocatedElement=FunctionAllocation_allocatedElement 
	 *         target=FunctionAllocation_target
	 *     )
	 */
	protected void sequence_FunctionAllocation(ISerializationContext context, FunctionAllocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionAllocation_allocatedElement returns FunctionAllocation_allocatedElement
	 *
	 * Constraint:
	 *     (
	 *         (allocateableElement_context+=[AllocateableElement|EString] allocateableElement_context+=[AllocateableElement|EString]*)? 
	 *         allocateableElement=[AllocateableElement|EString]
	 *     )
	 */
	protected void sequence_FunctionAllocation_allocatedElement(ISerializationContext context, FunctionAllocation_allocatedElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionAllocation_target returns FunctionAllocation_target
	 *
	 * Constraint:
	 *     (
	 *         (allocationTarget_context+=[AllocationTarget|EString] allocationTarget_context+=[AllocationTarget|EString]*)? 
	 *         allocationTarget=[AllocationTarget|EString]
	 *     )
	 */
	protected void sequence_FunctionAllocation_target(ISerializationContext context, FunctionAllocation_target semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns FunctionClientServerInterface
	 *     TraceableSpecification returns FunctionClientServerInterface
	 *     Identifiable returns FunctionClientServerInterface
	 *     EAElement returns FunctionClientServerInterface
	 *     FunctionClientServerInterface returns FunctionClientServerInterface
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         uri=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (operation+=Operation operation+=Operation*)?
	 *     )
	 */
	protected void sequence_FunctionClientServerInterface(ISerializationContext context, FunctionClientServerInterface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionPort returns FunctionClientServerPort
	 *     Identifiable returns FunctionClientServerPort
	 *     EAElement returns FunctionClientServerPort
	 *     AllocateableElement returns FunctionClientServerPort
	 *     FunctionClientServerPort returns FunctionClientServerPort
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         kind=ClientServerKind 
	 *         type=[FunctionClientServerInterface|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_FunctionClientServerPort(ISerializationContext context, FunctionClientServerPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns FunctionConnector
	 *     EAElement returns FunctionConnector
	 *     AllocateableElement returns FunctionConnector
	 *     FunctionConnector returns FunctionConnector
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         port+=FunctionConnector_port 
	 *         port+=FunctionConnector_port*
	 *     )
	 */
	protected void sequence_FunctionConnector(ISerializationContext context, FunctionConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionConnector_port returns FunctionConnector_port
	 *
	 * Constraint:
	 *     (functionPrototype=[FunctionPrototype|EString]? functionPort=[FunctionPort|EString])
	 */
	protected void sequence_FunctionConnector_port(ISerializationContext context, FunctionConnector_port semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionPort returns FunctionFlowPort
	 *     Identifiable returns FunctionFlowPort
	 *     EAElement returns FunctionFlowPort
	 *     AllocateableElement returns FunctionFlowPort
	 *     FunctionFlowPort returns FunctionFlowPort
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         direction=EADirectionKind 
	 *         type=[EADatatype|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         defaultValue=EAValue?
	 *     )
	 */
	protected void sequence_FunctionFlowPort(ISerializationContext context, FunctionFlowPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionPort returns FunctionPowerPort
	 *     Identifiable returns FunctionPowerPort
	 *     EAElement returns FunctionPowerPort
	 *     AllocateableElement returns FunctionPowerPort
	 *     FunctionPowerPort returns FunctionPowerPort
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         type=[CompositeDatatype|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_FunctionPowerPort(ISerializationContext context, FunctionPowerPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns FunctionalDevice
	 *     Identifiable returns FunctionalDevice
	 *     EAElement returns FunctionalDevice
	 *     AnalysisFunctionType returns FunctionalDevice
	 *     FunctionalDevice returns FunctionalDevice
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isElementary=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)? 
	 *         (connector+=FunctionConnector connector+=FunctionConnector*)? 
	 *         (port+=FunctionPort port+=FunctionPort*)? 
	 *         (part+=AnalysisFunctionPrototype part+=AnalysisFunctionPrototype*)?
	 *     )
	 */
	protected void sequence_FunctionalDevice(ISerializationContext context, FunctionalDevice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns HardwareComponentPrototype
	 *     EAElement returns HardwareComponentPrototype
	 *     AllocationTarget returns HardwareComponentPrototype
	 *     HardwareComponentPrototype returns HardwareComponentPrototype
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         type=[HardwareComponentType|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_HardwareComponentPrototype(ISerializationContext context, HardwareComponentPrototype semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns HardwareComponentType
	 *     HardwareComponentType returns HardwareComponentType
	 *     Identifiable returns HardwareComponentType
	 *     EAElement returns HardwareComponentType
	 *     HardwareComponentType_Impl returns HardwareComponentType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (pin+=HardwarePin pin+=HardwarePin*)? 
	 *         (part+=HardwareComponentPrototype part+=HardwareComponentPrototype*)? 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)? 
	 *         (port+=HardwarePort port+=HardwarePort*)? 
	 *         (portConnector+=PortConnector portConnector+=PortConnector*)?
	 *     )
	 */
	protected void sequence_HardwareComponentType_Impl(ISerializationContext context, HardwareComponentType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns HardwareConnector
	 *     EAElement returns HardwareConnector
	 *     HardwareConnector returns HardwareConnector
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         port+=HardwareConnector_port 
	 *         port+=HardwareConnector_port*
	 *     )
	 */
	protected void sequence_HardwareConnector(ISerializationContext context, HardwareConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwareConnector_port returns HardwareConnector_port
	 *
	 * Constraint:
	 *     (hardwarePin=[HardwarePin|EString] hardwareComponentPrototype=[HardwareComponentPrototype|EString]?)
	 */
	protected void sequence_HardwareConnector_port(ISerializationContext context, HardwareConnector_port semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns HardwareFunctionType
	 *     Identifiable returns HardwareFunctionType
	 *     DesignFunctionType returns HardwareFunctionType
	 *     EAElement returns HardwareFunctionType
	 *     HardwareFunctionType returns HardwareFunctionType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isElementary=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         hardwareComponent=[HardwareComponentType|EString]? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)? 
	 *         (connector+=FunctionConnector connector+=FunctionConnector*)? 
	 *         (port+=FunctionPort port+=FunctionPort*)? 
	 *         (part+=DesignFunctionPrototype part+=DesignFunctionPrototype*)?
	 *     )
	 */
	protected void sequence_HardwareFunctionType(ISerializationContext context, HardwareFunctionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PortConnector returns HardwarePortConnector
	 *     Identifiable returns HardwarePortConnector
	 *     EAElement returns HardwarePortConnector
	 *     AllocationTarget returns HardwarePortConnector
	 *     HardwarePortConnector returns HardwarePortConnector
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         port+=HardwarePortConnector_port 
	 *         port+=HardwarePortConnector_port* 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)?
	 *     )
	 */
	protected void sequence_HardwarePortConnector(ISerializationContext context, HardwarePortConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwarePortConnector_port returns HardwarePortConnector_port
	 *
	 * Constraint:
	 *     (hardwarePort=[HardwarePort|EString] hardwareComponentPrototype=[HardwareComponentPrototype|EString]?)
	 */
	protected void sequence_HardwarePortConnector_port(ISerializationContext context, HardwarePortConnector_port semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns HardwarePort
	 *     EAElement returns HardwarePort
	 *     AllocationTarget returns HardwarePort
	 *     HardwarePort returns HardwarePort
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isShield=Boolean? 
	 *         (referencedPin+=[HardwarePin|EString] referencedPin+=[HardwarePin|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (containedPin+=HardwarePin containedPin+=HardwarePin*)? 
	 *         (containedPort+=HardwarePort containedPort+=HardwarePort*)?
	 *     )
	 */
	protected void sequence_HardwarePort(ISerializationContext context, HardwarePort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwarePin returns IOHardwarePin
	 *     Identifiable returns IOHardwarePin
	 *     EAElement returns IOHardwarePin
	 *     AllocationTarget returns IOHardwarePin
	 *     IOHardwarePin returns IOHardwarePin
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         direction=EADirectionKind? 
	 *         isGround=Boolean? 
	 *         kind=IOHardwarePinKind? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_IOHardwarePin(ISerializationContext context, IOHardwarePin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns LocalDeviceManager
	 *     Identifiable returns LocalDeviceManager
	 *     DesignFunctionType returns LocalDeviceManager
	 *     EAElement returns LocalDeviceManager
	 *     LocalDeviceManager returns LocalDeviceManager
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         isElementary=Boolean? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)? 
	 *         (connector+=FunctionConnector connector+=FunctionConnector*)? 
	 *         (port+=FunctionPort port+=FunctionPort*)? 
	 *         (part+=DesignFunctionPrototype part+=DesignFunctionPrototype*)?
	 *     )
	 */
	protected void sequence_LocalDeviceManager(ISerializationContext context, LocalDeviceManager semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PortConnector returns LogicalPortConnector
	 *     Identifiable returns LogicalPortConnector
	 *     EAElement returns LogicalPortConnector
	 *     AllocationTarget returns LogicalPortConnector
	 *     LogicalPortConnector returns LogicalPortConnector
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         kind=HardwareBusKind? 
	 *         busSpeed=Float? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         port+=HardwarePortConnector_port 
	 *         port+=HardwarePortConnector_port*
	 *     )
	 */
	protected void sequence_LogicalPortConnector(ISerializationContext context, LogicalPortConnector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns Node
	 *     HardwareComponentType returns Node
	 *     Identifiable returns Node
	 *     EAElement returns Node
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         executionRate=Float? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (pin+=HardwarePin pin+=HardwarePin*)? 
	 *         (part+=HardwareComponentPrototype part+=HardwareComponentPrototype*)? 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)? 
	 *         (port+=HardwarePort port+=HardwarePort*)? 
	 *         (portConnector+=PortConnector portConnector+=PortConnector*)?
	 *     )
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns Operation
	 *     EAElement returns Operation
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         return=EADatatypePrototype? 
	 *         (argument+=EADatatypePrototype argument+=EADatatypePrototype*)?
	 *     )
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Identifiable returns PortGroup
	 *     EAElement returns PortGroup
	 *     PortGroup returns PortGroup
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (port+=[FunctionPort|EString] port+=[FunctionPort|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (portGroup+=PortGroup portGroup+=PortGroup*)?
	 *     )
	 */
	protected void sequence_PortGroup(ISerializationContext context, PortGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HardwarePin returns PowerHardwarePin
	 *     Identifiable returns PowerHardwarePin
	 *     EAElement returns PowerHardwarePin
	 *     AllocationTarget returns PowerHardwarePin
	 *     PowerHardwarePin returns PowerHardwarePin
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         direction=EADirectionKind? 
	 *         isGround=Boolean? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_PowerHardwarePin(ISerializationContext context, PowerHardwarePin semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns Quantity
	 *     Identifiable returns Quantity
	 *     EAElement returns Quantity
	 *     Quantity returns Quantity
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         amountOfSubstanceExp=Integer 
	 *         electricCurrentExp=Integer 
	 *         lengthExp=Integer 
	 *         luminousIntensityExp=Integer 
	 *         massExp=Integer 
	 *         thermodynamicTemperatureExp=Integer 
	 *         timeExp=Integer 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_Quantity(ISerializationContext context, Quantity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns RangeableValueType
	 *     TraceableSpecification returns RangeableValueType
	 *     EADatatype returns RangeableValueType
	 *     Identifiable returns RangeableValueType
	 *     EAElement returns RangeableValueType
	 *     RangeableValueType returns RangeableValueType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         text=String0? 
	 *         uri=String0? 
	 *         accuracy=Float 
	 *         resolution=Float 
	 *         significantDigits=Integer? 
	 *         baseRangeable=[EANumerical|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_RangeableValueType(ISerializationContext context, RangeableValueType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Comment returns Rationale
	 *     Rationale returns Rationale
	 *
	 * Constraint:
	 *     body=String0
	 */
	protected void sequence_Rationale(ISerializationContext context, Rationale semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Eastadl22Package.eINSTANCE.getComment_Body()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Eastadl22Package.eINSTANCE.getComment_Body()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRationaleAccess().getBodyString0ParserRuleCall_1_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Relationship returns Realization
	 *     Identifiable returns Realization
	 *     EAElement returns Realization
	 *     Realization returns Realization
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         realized+=Realization_realized 
	 *         realized+=Realization_realized* 
	 *         realizedBy+=Realization_realizedBy 
	 *         realizedBy+=Realization_realizedBy*
	 *     )
	 */
	protected void sequence_Realization(ISerializationContext context, Realization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Realization_realizedBy returns Realization_realizedBy
	 *
	 * Constraint:
	 *     (identifiable_target=[Identifiable|EString] (identifiable_context+=[Identifiable|EString] identifiable_context+=[Identifiable|EString]*)?)
	 */
	protected void sequence_Realization_realizedBy(ISerializationContext context, Realization_realizedBy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Realization_realized returns Realization_realized
	 *
	 * Constraint:
	 *     (identifiable_target=[EAElement|EString] (identifiable_context+=[EAElement|EString] identifiable_context+=[EAElement|EString]*)?)
	 */
	protected void sequence_Realization_realized(ISerializationContext context, Realization_realized semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns Sensor
	 *     HardwareComponentType returns Sensor
	 *     Identifiable returns Sensor
	 *     EAElement returns Sensor
	 *     Sensor returns Sensor
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (traceableSpecification+=[TraceableSpecification|EString] traceableSpecification+=[TraceableSpecification|EString]*)? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (ownedRelationship+=Relationship ownedRelationship+=Relationship*)? 
	 *         (pin+=HardwarePin pin+=HardwarePin*)? 
	 *         (part+=HardwareComponentPrototype part+=HardwareComponentPrototype*)? 
	 *         (connector+=HardwareConnector connector+=HardwareConnector*)? 
	 *         (port+=HardwarePort port+=HardwarePort*)? 
	 *         (portConnector+=PortConnector portConnector+=PortConnector*)?
	 *     )
	 */
	protected void sequence_Sensor(ISerializationContext context, Sensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns Unit
	 *     Identifiable returns Unit
	 *     EAElement returns Unit
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         factor=Float 
	 *         symbol=String0 
	 *         offset=Float 
	 *         reference=[Unit|EString]? 
	 *         quantity=[Quantity|EString]? 
	 *         (ownedComment+=Comment ownedComment+=Comment*)?
	 *     )
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns UserAttributeDefinition
	 *     Identifiable returns UserAttributeDefinition
	 *     EAElement returns UserAttributeDefinition
	 *     UserAttributeDefinition returns UserAttributeDefinition
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         type=[EADatatype|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         defaultValue=EAValue?
	 *     )
	 */
	protected void sequence_UserAttributeDefinition(ISerializationContext context, UserAttributeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns UserAttributedElement
	 *     Identifiable returns UserAttributedElement
	 *     EAElement returns UserAttributedElement
	 *     UserAttributedElement returns UserAttributedElement
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         (uaType+=[UserElementType|EString] uaType+=[UserElementType|EString]*)? 
	 *         attributedElement=[Identifiable|EString] 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (uaValue+=EAValue uaValue+=EAValue*)?
	 *     )
	 */
	protected void sequence_UserAttributedElement(ISerializationContext context, UserAttributedElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EAPackageableElement returns UserElementType
	 *     Identifiable returns UserElementType
	 *     EAElement returns UserElementType
	 *     UserElementType returns UserElementType
	 *
	 * Constraint:
	 *     (
	 *         shortName=Identifier 
	 *         category=Identifier? 
	 *         uuid=String0? 
	 *         name=String0? 
	 *         validFor=String0? 
	 *         key=String0 
	 *         (ownedComment+=Comment ownedComment+=Comment*)? 
	 *         (uaDefinition+=UserAttributeDefinition uaDefinition+=UserAttributeDefinition*)?
	 *     )
	 */
	protected void sequence_UserElementType(ISerializationContext context, UserElementType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XBlockExpression returns XBlockExpression
	 *     XExpression returns XBlockExpression
	 *     XAssignment returns XBlockExpression
	 *     XAssignment.XBinaryOperation_1_1_0_0_0 returns XBlockExpression
	 *     XOrExpression returns XBlockExpression
	 *     XOrExpression.XBinaryOperation_1_0_0_0 returns XBlockExpression
	 *     XAndExpression returns XBlockExpression
	 *     XAndExpression.XBinaryOperation_1_0_0_0 returns XBlockExpression
	 *     XEqualityExpression returns XBlockExpression
	 *     XEqualityExpression.XBinaryOperation_1_0_0_0 returns XBlockExpression
	 *     XRelationalExpression returns XBlockExpression
	 *     XRelationalExpression.XInstanceOfExpression_1_0_0_0_0 returns XBlockExpression
	 *     XRelationalExpression.XBinaryOperation_1_1_0_0_0 returns XBlockExpression
	 *     XOtherOperatorExpression returns XBlockExpression
	 *     XOtherOperatorExpression.XBinaryOperation_1_0_0_0 returns XBlockExpression
	 *     XAdditiveExpression returns XBlockExpression
	 *     XAdditiveExpression.XBinaryOperation_1_0_0_0 returns XBlockExpression
	 *     XMultiplicativeExpression returns XBlockExpression
	 *     XMultiplicativeExpression.XBinaryOperation_1_0_0_0 returns XBlockExpression
	 *     XUnaryOperation returns XBlockExpression
	 *     XCastedExpression returns XBlockExpression
	 *     XCastedExpression.XCastedExpression_1_0_0_0 returns XBlockExpression
	 *     XPostfixOperation returns XBlockExpression
	 *     XPostfixOperation.XPostfixOperation_1_0_0 returns XBlockExpression
	 *     XMemberFeatureCall returns XBlockExpression
	 *     XMemberFeatureCall.XAssignment_1_0_0_0_0 returns XBlockExpression
	 *     XMemberFeatureCall.XMemberFeatureCall_1_1_0_0_0 returns XBlockExpression
	 *     XPrimaryExpression returns XBlockExpression
	 *     XParenthesizedExpression returns XBlockExpression
	 *     XExpressionOrVarDeclaration returns XBlockExpression
	 *
	 * Constraint:
	 *     expressions+=XExpressionOrVarDeclaration*
	 */
	protected void sequence_XBlockExpression(ISerializationContext context, XBlockExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
