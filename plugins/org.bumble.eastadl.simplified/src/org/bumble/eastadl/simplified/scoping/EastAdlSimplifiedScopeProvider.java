/*
 * generated by Xtext 2.22.0
 */
package org.bumble.eastadl.simplified.scoping;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.ILog;
import org.eclipse.core.runtime.Platform;
import org.eclipse.eatop.eastadl22.AllocateableElement;
import org.eclipse.eatop.eastadl22.AllocationTarget;
import org.eclipse.eatop.eastadl22.AnalysisFunctionPrototype;
import org.eclipse.eatop.eastadl22.AnalysisFunctionType;
import org.eclipse.eatop.eastadl22.ArrayDatatype;
import org.eclipse.eatop.eastadl22.BasicSoftwareFunctionType;
import org.eclipse.eatop.eastadl22.CompositeDatatype;
import org.eclipse.eatop.eastadl22.DesignFunctionPrototype;
import org.eclipse.eatop.eastadl22.DesignFunctionType;
import org.eclipse.eatop.eastadl22.DesignLevel;
import org.eclipse.eatop.eastadl22.EAArrayValue;
import org.eclipse.eatop.eastadl22.EABooleanValue;
import org.eclipse.eatop.eastadl22.EACompositeValue;
import org.eclipse.eatop.eastadl22.EADatatype;
import org.eclipse.eatop.eastadl22.EADatatypePrototype;
import org.eclipse.eatop.eastadl22.EAElement;
import org.eclipse.eatop.eastadl22.EAEnumerationValue;
import org.eclipse.eatop.eastadl22.EAExpression;
import org.eclipse.eatop.eastadl22.EANumerical;
import org.eclipse.eatop.eastadl22.EANumericalValue;
import org.eclipse.eatop.eastadl22.EAStringValue;
import org.eclipse.eatop.eastadl22.Eastadl22Package;
import org.eclipse.eatop.eastadl22.EnumerationLiteral;
import org.eclipse.eatop.eastadl22.FunctionAllocation_allocatedElement;
import org.eclipse.eatop.eastadl22.FunctionAllocation_target;
import org.eclipse.eatop.eastadl22.FunctionClientServerInterface;
import org.eclipse.eatop.eastadl22.FunctionClientServerPort;
import org.eclipse.eatop.eastadl22.FunctionConnector_port;
import org.eclipse.eatop.eastadl22.FunctionFlowPort;
import org.eclipse.eatop.eastadl22.FunctionPort;
import org.eclipse.eatop.eastadl22.FunctionPowerPort;
import org.eclipse.eatop.eastadl22.FunctionPrototype;
import org.eclipse.eatop.eastadl22.HardwareComponentPrototype;
import org.eclipse.eatop.eastadl22.HardwareComponentType;
import org.eclipse.eatop.eastadl22.HardwareConnector_port;
import org.eclipse.eatop.eastadl22.HardwareFunctionType;
import org.eclipse.eatop.eastadl22.HardwarePin;
import org.eclipse.eatop.eastadl22.HardwarePort;
import org.eclipse.eatop.eastadl22.HardwarePortConnector_port;
import org.eclipse.eatop.eastadl22.Identifiable;
import org.eclipse.eatop.eastadl22.PortGroup;
import org.eclipse.eatop.eastadl22.Quantity;
import org.eclipse.eatop.eastadl22.RangeableValueType;
import org.eclipse.eatop.eastadl22.Realization_realized;
import org.eclipse.eatop.eastadl22.Realization_realizedBy;
import org.eclipse.eatop.eastadl22.Referrable;
import org.eclipse.eatop.eastadl22.Unit;
import org.eclipse.eatop.eastadl22.UserAttributeDefinition;
import org.eclipse.eatop.eastadl22.UserAttributedElement;
import org.eclipse.eatop.eastadl22.UserElementType;
import org.eclipse.eatop.eastadl22.util.Eastadl22ResourceFactoryImpl;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.testing.util.ParseHelper;

import com.google.common.base.Function;
import com.google.inject.Inject;

/**
 * This class contains custom scoping description.
 * 
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class EastAdlSimplifiedScopeProvider extends AbstractEastAdlSimplifiedScopeProvider {
	
	private ILog logger = Platform.getLog(getClass());

	@Inject
	IQualifiedNameProvider nameProvider;

	@Inject
	ParseHelper<EObject> parseHelper;

	@Inject
	private XtextResourceSet resourceSet;

	@Override
	public IScope getScope(EObject context, EReference reference) {
		EClass contextEClass = context.eClass();
		String contextClassName = null;

		// Get the raw paths of all the eatxt file in the same project
		List<String> eatxtFileRawPaths = getAllFilesForEObjectProject(context, "eatxt");
		List<String> eaxmlFileRawPaths = getAllFilesForEObjectProject(context, "eaxml");

		// Get the root elements of all the eatxt files in the same project
		List<EObject> rootElements = getAllEatxtRootElements(eatxtFileRawPaths);

		// Add the root elements of all the eaxml files in the same project to the list
		getAllEaxmlRootElements(rootElements, eaxmlFileRawPaths);

		// A dedicated process for HardwareComponentPrototype in DesignLevel
		// Normal case: in class A reference type B, then the context is A and target is
		// B
		// Special case: in class DesignLevel reference type HardwareComponentType, the
		// context is DesignLevel
		if (contextEClass.getInstanceTypeName().equals(DesignLevel.class.getName())
				&& reference.getContainerClass().getName().equals(HardwareComponentPrototype.class.getName())) {
			DesignLevel designLevel = (DesignLevel) context;
			contextClassName = designLevel.getHardwareDesignArchitecture().eClass().getInstanceTypeName();
		} else {
			contextClassName = contextEClass.getInstanceTypeName();
		}

		EClass targetEClass = reference.getEReferenceType();
		String targetClassName = targetEClass.getInstanceTypeName();

		// The ugly and long if conditions were combined with pairs of context and
		// target, which is used to
		// limit the automatic proposals by filtering the scopes
		if ((contextClassName.equals(DesignFunctionPrototype.class.getName())
				&& targetClassName.equals(DesignFunctionType.class.getName()))
				|| (contextClassName.equals(RangeableValueType.class.getName())
						&& targetClassName.equals(EANumerical.class.getName()))
				|| ((contextClassName.equals(EANumerical.class.getName())
						|| contextClassName.equals(Unit.class.getName()))
						&& targetClassName.equals(Unit.class.getName()))
				|| (contextClassName.equals(Unit.class.getName()) && targetClassName.equals(Quantity.class.getName()))
				|| (contextClassName.equals(UserAttributedElement.class.getName())
						|| targetClassName.equals(UserElementType.class.getName()))
				|| ((contextClassName.equals(HardwareConnector_port.class.getName())
						|| contextClassName.equals(HardwarePortConnector_port.class.getName()))
						&& targetClassName.equals(HardwareComponentPrototype.class.getName()))
				|| (contextClassName.equals(Realization_realized.class.getName())
						&& targetClassName.equals(EAElement.class.getName()))
				|| ((contextClassName.equals(UserAttributedElement.class.getName())
						|| contextClassName.equals(Realization_realizedBy.class.getName()))
						&& targetClassName.equals(Identifiable.class.getName()))
				|| ((contextClassName.equals(HardwareFunctionType.class.getName())
						|| contextClassName.equals(HardwareComponentPrototype.class.getName()))
						&& targetClassName.equals(HardwareComponentType.class.getName()))
				|| (contextClassName.equals(AnalysisFunctionPrototype.class.getName())
						&& targetClassName.equals(AnalysisFunctionType.class.getName()))
				|| (contextClassName.equals(FunctionClientServerPort.class.getName())
						&& targetClassName.equals(FunctionClientServerInterface.class.getName()))
				|| (contextClassName.equals(FunctionPowerPort.class.getName())
						&& targetClassName.equals(CompositeDatatype.class.getName()))
				|| ((contextClassName.equals(ArrayDatatype.class.getName())
						|| contextClassName.equals(UserAttributeDefinition.class.getName())
						|| contextClassName.equals(FunctionFlowPort.class.getName())
						|| contextClassName.equals(EADatatypePrototype.class.getName())
						|| contextClassName.equals(EAArrayValue.class.getName())
						|| contextClassName.equals(EABooleanValue.class.getName())
						|| contextClassName.equals(EACompositeValue.class.getName())
						|| contextClassName.equals(EAEnumerationValue.class.getName())
						|| contextClassName.equals(EAExpression.class.getName())
						|| contextClassName.equals(EANumericalValue.class.getName())
						|| contextClassName.equals(EAStringValue.class.getName()))
						&& targetClassName.equals(EADatatype.class.getName()))
				|| (contextClassName.equals(FunctionAllocation_allocatedElement.class.getName())
						&& targetClassName.equals(AllocateableElement.class.getName()))
				|| (contextClassName.equals(FunctionAllocation_target.class.getName())
						&& targetClassName.equals(AllocationTarget.class.getName()))
				|| (contextClassName.equals(FunctionConnector_port.class.getName())
						&& targetClassName.equals(FunctionPrototype.class.getName()))
				|| ((contextClassName.equals(PortGroup.class.getName())
						|| contextClassName.equals(FunctionConnector_port.class.getName()))
						&& targetClassName.equals(FunctionPort.class.getName()))
				|| ((contextClassName.equals(HardwarePort.class.getName())
						|| contextClassName.equals(HardwareConnector_port.class.getName()))
						&& targetClassName.equals(HardwarePin.class.getName()))
				|| (contextClassName.equals(HardwarePortConnector_port.class.getName())
						&& targetClassName.equals(HardwarePort.class.getName()))
				|| (contextClassName.equals(EAEnumerationValue.class.getName())
						&& targetClassName.equals(EnumerationLiteral.class.getName()))
				|| (contextClassName.equals(DesignFunctionType.class.getName())
						&& targetClassName.equals(EADatatype.class.getName()))
				|| (contextClassName.equals(BasicSoftwareFunctionType.class.getName())
						&& targetClassName.equals(EADatatype.class.getName()))
				|| (contextClassName.equals(AnalysisFunctionType.class.getName())
						&& targetClassName.equals(EADatatype.class.getName()))) {
			List<Referrable> globalCandidates = new ArrayList<Referrable>();
			Class targetJavaClass = null;
			try {
				targetJavaClass = Class.forName(targetEClass.getInstanceTypeName());
				if (targetJavaClass != null) {
					EObject rootElement = EcoreUtil2.getRootContainer(context);
					globalCandidates
							.addAll((List<Referrable>) EcoreUtil2.getAllContentsOfType(rootElement, targetJavaClass));
				}
			} catch (ClassNotFoundException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			for (EObject rootElement : rootElements) {
				if (targetJavaClass != null) {
					List<Referrable> candidates = (List<Referrable>) EcoreUtil2.getAllContentsOfType(rootElement,
							targetJavaClass);
					globalCandidates.addAll(candidates);
				}
			}

			if (globalCandidates.size() > 0) {
				Predicate<Referrable> nullShortName = c -> c.getShortName() == null;
				globalCandidates.removeIf(nullShortName);

				// get the fully qualified name of a display short name, which will be a full
				// path of string
				Function<Referrable, QualifiedName> displayShortNames = x -> nameProvider.getFullyQualifiedName(x);

				// return all the fulfilled proposals (which would be proposed automatically in
				// the menu to user)
				return Scopes.scopeFor(globalCandidates, displayShortNames, IScope.NULLSCOPE);
			}
		}
		// TODO: generalize the procedure so that it works as above also for all
		// Allocations. As this is more complicated, probably an extra if-block has to
		// be implemented for this

		// FIXME: Does not work for the same name in different namespaces right now!

		// if no judgement condition above is fulfiled, then the program will get here
		// and invoke supertype's getScope method
		return super.getScope(context, reference);
	}

	public EObject getEMFModel(String filePath, XtextResourceSet xtextResourceSet) {
		// We need to make sure that EMF knows where to find the right resource factory
		xtextResourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put("eaxml",
				new Eastadl22ResourceFactoryImpl());
		xtextResourceSet.getPackageRegistry().put(Eastadl22Package.eNS_URI, Eastadl22Package.eINSTANCE);
		URI openUri = URI.createFileURI(new File(filePath).getAbsolutePath());

		// We are now getting an instance of Eastadl22ResourceImpl here
		Resource xmlResource = xtextResourceSet.getResource(openUri, true);

		// And calling load() will deserialise the EAXML into an in-memory model
		try {
			xmlResource.load(null);
		} catch (IOException e) {
			logger.warn("EAXML file " + filePath + " could not be loaded.", e);
			return null;
		}

		EObject topLevelObject = xmlResource.getContents().get(0);

		return topLevelObject;
	}

	private void getAllEaxmlRootElements(List<EObject> currentElementList, List<String> eaxmlFileRawPaths) {
		for (String path : eaxmlFileRawPaths) {
			EObject rootElement = getEMFModel(path, resourceSet);

			if (rootElement == null)
				continue;

			currentElementList.add(rootElement);
		}
	}

	private List<EObject> getAllEatxtRootElements(List<String> fileRawPaths) {
		List<EObject> output = new ArrayList<EObject>();

		for (String filePath : fileRawPaths) {
			try {
				String dslContents = new String(Files.readAllBytes(Paths.get(filePath)));
				try {
					EObject eaxml = parseHelper.parse(dslContents);

					if (eaxml != null) {
						output.add(eaxml);
					}
				} catch (Exception e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		return output;
	}

	/**
	 * Retrieves the project the {@code context} is stored in and retrieves all
	 * other files with the given {@code extension} in it.
	 * 
	 * @param context   the {@link EObject} whose project files should be retrieved
	 * @param extension the extension of the files of interest
	 * @return a list of OS paths to files with the given extension in the
	 *         {@code context}'s project
	 */
	private List<String> getAllFilesForEObjectProject(EObject context, String extension) {
		if (extension == null) {
			throw new IllegalArgumentException("Extension cannot be null");
		}
		List<String> output = new ArrayList<String>();
		URI uri = context.eResource().getURI();
		IWorkspace workspace = ResourcesPlugin.getWorkspace();
		IProject[] projects = workspace.getRoot().getProjects();
		// get the relative path of project
		String[] segments = uri.segments();
		String projectName = "";

		if (segments.length > 1) {
			projectName = segments[1];
		}
		for (IProject project : projects) {
			if (project.getName().equals(projectName)) {
				try {
					for (IResource resource : project.members()) {
						String path = resource.getRawLocation().toOSString();
						if (extension.equals(resource.getFileExtension())) {
							output.add(path);
						}
					}
				} catch (CoreException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}

		return output;
	}

}
