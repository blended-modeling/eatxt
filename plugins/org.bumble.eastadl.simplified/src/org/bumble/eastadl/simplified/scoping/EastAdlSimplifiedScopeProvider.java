/*
 * generated by Xtext 2.22.0
 */
package org.bumble.eastadl.simplified.scoping;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

import org.bumble.eastadl.simplified.common.resource.EatxtResource;
import org.bumble.eastadl.simplified.common.resource.EatxtResourceFactory;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceVisitor;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.ILog;
import org.eclipse.core.runtime.Platform;
import org.eclipse.eatop.eastadl22.AllocateableElement;
import org.eclipse.eatop.eastadl22.AllocationTarget;
import org.eclipse.eatop.eastadl22.AnalysisFunctionPrototype;
import org.eclipse.eatop.eastadl22.AnalysisFunctionType;
import org.eclipse.eatop.eastadl22.ArrayDatatype;
import org.eclipse.eatop.eastadl22.BasicSoftwareFunctionType;
import org.eclipse.eatop.eastadl22.CompositeDatatype;
import org.eclipse.eatop.eastadl22.DesignFunctionPrototype;
import org.eclipse.eatop.eastadl22.DesignFunctionType;
import org.eclipse.eatop.eastadl22.DesignLevel;
import org.eclipse.eatop.eastadl22.EAArrayValue;
import org.eclipse.eatop.eastadl22.EABooleanValue;
import org.eclipse.eatop.eastadl22.EACompositeValue;
import org.eclipse.eatop.eastadl22.EADatatype;
import org.eclipse.eatop.eastadl22.EADatatypePrototype;
import org.eclipse.eatop.eastadl22.EAElement;
import org.eclipse.eatop.eastadl22.EAEnumerationValue;
import org.eclipse.eatop.eastadl22.EAExpression;
import org.eclipse.eatop.eastadl22.EANumerical;
import org.eclipse.eatop.eastadl22.EANumericalValue;
import org.eclipse.eatop.eastadl22.EAStringValue;
import org.eclipse.eatop.eastadl22.Eastadl22Package;
import org.eclipse.eatop.eastadl22.EnumerationLiteral;
import org.eclipse.eatop.eastadl22.FunctionAllocation_allocatedElement;
import org.eclipse.eatop.eastadl22.FunctionAllocation_target;
import org.eclipse.eatop.eastadl22.FunctionClientServerInterface;
import org.eclipse.eatop.eastadl22.FunctionClientServerPort;
import org.eclipse.eatop.eastadl22.FunctionConnector_port;
import org.eclipse.eatop.eastadl22.FunctionFlowPort;
import org.eclipse.eatop.eastadl22.FunctionPort;
import org.eclipse.eatop.eastadl22.FunctionPowerPort;
import org.eclipse.eatop.eastadl22.FunctionPrototype;
import org.eclipse.eatop.eastadl22.HardwareComponentPrototype;
import org.eclipse.eatop.eastadl22.HardwareComponentType;
import org.eclipse.eatop.eastadl22.HardwareConnector_port;
import org.eclipse.eatop.eastadl22.HardwareFunctionType;
import org.eclipse.eatop.eastadl22.HardwarePin;
import org.eclipse.eatop.eastadl22.HardwarePort;
import org.eclipse.eatop.eastadl22.HardwarePortConnector_port;
import org.eclipse.eatop.eastadl22.Identifiable;
import org.eclipse.eatop.eastadl22.PortGroup;
import org.eclipse.eatop.eastadl22.Quantity;
import org.eclipse.eatop.eastadl22.RangeableValueType;
import org.eclipse.eatop.eastadl22.Realization_realized;
import org.eclipse.eatop.eastadl22.Realization_realizedBy;
import org.eclipse.eatop.eastadl22.Referrable;
import org.eclipse.eatop.eastadl22.Unit;
import org.eclipse.eatop.eastadl22.UserAttributeDefinition;
import org.eclipse.eatop.eastadl22.UserAttributedElement;
import org.eclipse.eatop.eastadl22.UserElementType;
import org.eclipse.eatop.eastadl22.util.Eastadl22ResourceFactoryImpl;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.testing.util.ParseHelper;

import com.google.common.base.Function;
import com.google.inject.Inject;
import com.google.inject.Provider;

/**
 * This class contains custom scoping description. In particular, it constructs
 * a global scope of all East-ADL models, regardless or concrete syntax.
 * <p>
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class EastAdlSimplifiedScopeProvider extends AbstractEastAdlSimplifiedScopeProvider {

	private ILog logger = Platform.getLog(getClass());

	@Inject
	IQualifiedNameProvider nameProvider;

	@Inject
	ParseHelper<EObject> parseHelper;

	@Inject
	private Provider<EatxtResource> resourceProvider;

	@Inject
	private XtextResourceSet resourceSet;

	@Override
	public IScope getScope(EObject context, EReference reference) {
		EClass contextEClass = context.eClass();
		String contextClassName = null;

		// Get the raw paths of all the relevant files in the workspace
		List<URI> fileUris = getAllFilesInWorkspace(Arrays.asList("eatxt", "eaxml"));

		// Get the root elements of all relevant files
		List<EObject> rootElements = new ArrayList<>();

		for (URI uri : fileUris) {
			rootElements.add(getEMFModel(uri, resourceSet));
		}

		// A dedicated process for HardwareComponentPrototype in DesignLevel
		// Normal case: in class A reference type B, then the context is A and target is
		// B
		// Special case: in class DesignLevel reference type HardwareComponentType, the
		// context is DesignLevel
		if (contextEClass.getInstanceTypeName().equals(DesignLevel.class.getName())
				&& reference.getContainerClass().getName().equals(HardwareComponentPrototype.class.getName())) {
			DesignLevel designLevel = (DesignLevel) context;
			contextClassName = designLevel.getHardwareDesignArchitecture().eClass().getInstanceTypeName();
		} else {
			contextClassName = contextEClass.getInstanceTypeName();
		}

		EClass targetEClass = reference.getEReferenceType();
		String targetClassName = targetEClass.getInstanceTypeName();

		// The ugly and long if conditions were combined with pairs of context and
		// target, which is used to
		// limit the automatic proposals by filtering the scopes
		if ((contextClassName.equals(DesignFunctionPrototype.class.getName())
				&& targetClassName.equals(DesignFunctionType.class.getName()))
				|| (contextClassName.equals(RangeableValueType.class.getName())
						&& targetClassName.equals(EANumerical.class.getName()))
				|| ((contextClassName.equals(EANumerical.class.getName())
						|| contextClassName.equals(Unit.class.getName()))
						&& targetClassName.equals(Unit.class.getName()))
				|| (contextClassName.equals(Unit.class.getName()) && targetClassName.equals(Quantity.class.getName()))
				|| (contextClassName.equals(UserAttributedElement.class.getName())
						|| targetClassName.equals(UserElementType.class.getName()))
				|| ((contextClassName.equals(HardwareConnector_port.class.getName())
						|| contextClassName.equals(HardwarePortConnector_port.class.getName()))
						&& targetClassName.equals(HardwareComponentPrototype.class.getName()))
				|| (contextClassName.equals(Realization_realized.class.getName())
						&& targetClassName.equals(EAElement.class.getName()))
				|| ((contextClassName.equals(UserAttributedElement.class.getName())
						|| contextClassName.equals(Realization_realizedBy.class.getName()))
						&& targetClassName.equals(Identifiable.class.getName()))
				|| ((contextClassName.equals(HardwareFunctionType.class.getName())
						|| contextClassName.equals(HardwareComponentPrototype.class.getName()))
						&& targetClassName.equals(HardwareComponentType.class.getName()))
				|| (contextClassName.equals(AnalysisFunctionPrototype.class.getName())
						&& targetClassName.equals(AnalysisFunctionType.class.getName()))
				|| (contextClassName.equals(FunctionClientServerPort.class.getName())
						&& targetClassName.equals(FunctionClientServerInterface.class.getName()))
				|| (contextClassName.equals(FunctionPowerPort.class.getName())
						&& targetClassName.equals(CompositeDatatype.class.getName()))
				|| ((contextClassName.equals(ArrayDatatype.class.getName())
						|| contextClassName.equals(UserAttributeDefinition.class.getName())
						|| contextClassName.equals(FunctionFlowPort.class.getName())
						|| contextClassName.equals(EADatatypePrototype.class.getName())
						|| contextClassName.equals(EAArrayValue.class.getName())
						|| contextClassName.equals(EABooleanValue.class.getName())
						|| contextClassName.equals(EACompositeValue.class.getName())
						|| contextClassName.equals(EAEnumerationValue.class.getName())
						|| contextClassName.equals(EAExpression.class.getName())
						|| contextClassName.equals(EANumericalValue.class.getName())
						|| contextClassName.equals(EAStringValue.class.getName()))
						&& targetClassName.equals(EADatatype.class.getName()))
				|| (contextClassName.equals(FunctionAllocation_allocatedElement.class.getName())
						&& targetClassName.equals(AllocateableElement.class.getName()))
				|| (contextClassName.equals(FunctionAllocation_target.class.getName())
						&& targetClassName.equals(AllocationTarget.class.getName()))
				|| (contextClassName.equals(FunctionConnector_port.class.getName())
						&& targetClassName.equals(FunctionPrototype.class.getName()))
				|| ((contextClassName.equals(PortGroup.class.getName())
						|| contextClassName.equals(FunctionConnector_port.class.getName()))
						&& targetClassName.equals(FunctionPort.class.getName()))
				|| ((contextClassName.equals(HardwarePort.class.getName())
						|| contextClassName.equals(HardwareConnector_port.class.getName()))
						&& targetClassName.equals(HardwarePin.class.getName()))
				|| (contextClassName.equals(HardwarePortConnector_port.class.getName())
						&& targetClassName.equals(HardwarePort.class.getName()))
				|| (contextClassName.equals(EAEnumerationValue.class.getName())
						&& targetClassName.equals(EnumerationLiteral.class.getName()))
				|| (contextClassName.equals(DesignFunctionType.class.getName())
						&& targetClassName.equals(EADatatype.class.getName()))
				|| (contextClassName.equals(BasicSoftwareFunctionType.class.getName())
						&& targetClassName.equals(EADatatype.class.getName()))
				|| (contextClassName.equals(AnalysisFunctionType.class.getName())
						&& targetClassName.equals(EADatatype.class.getName()))) {
			List<Referrable> globalCandidates = new ArrayList<Referrable>();
			Class targetJavaClass = null;
			try {
				targetJavaClass = Class.forName(targetEClass.getInstanceTypeName());
				if (targetJavaClass != null) {
					EObject rootElement = EcoreUtil2.getRootContainer(context);
					globalCandidates
							.addAll((List<Referrable>) EcoreUtil2.getAllContentsOfType(rootElement, targetJavaClass));
				}
			} catch (ClassNotFoundException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			for (EObject rootElement : rootElements) {
				if (targetJavaClass != null) {
					List<Referrable> candidates = (List<Referrable>) EcoreUtil2.getAllContentsOfType(rootElement,
							targetJavaClass);
					globalCandidates.addAll(candidates);
				}
			}

			if (globalCandidates.size() > 0) {
				Predicate<Referrable> nullShortName = c -> c.getShortName() == null;
				globalCandidates.removeIf(nullShortName);

				// get the fully qualified name of a display short name, which will be a full
				// path of string
				Function<Referrable, QualifiedName> displayShortNames = x -> nameProvider.getFullyQualifiedName(x);

				// return all the fulfilled proposals using our own scope implementation that is
				// aware of "ea" URIs
				return new EastAdlSimplifiedScope(IScope.NULLSCOPE,
						Scopes.scopedElementsFor(globalCandidates, displayShortNames));
			}
		}
		// TODO: generalize the procedure so that it works as above also for all
		// Allocations. As this is more complicated, probably an extra if-block has to
		// be implemented for this

		// FIXME: Does not work for the same name in different namespaces right now!

		// if no judgement condition above is fulfiled, then the program will get here
		// and invoke supertype's getScope method
		return super.getScope(context, reference);
	}

	public EObject getEMFModel(URI fileUri, ResourceSet resourceSet) {
		// We need to make sure that EMF knows where to find the right resource factory
		resourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put("eaxml",
				new Eastadl22ResourceFactoryImpl());
		resourceSet.getPackageRegistry().put(Eastadl22Package.eNS_URI, Eastadl22Package.eINSTANCE);

		// We need to make sure that EMF uses the right resource for our eatxt file...
		resourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put("eatxt",
				new EatxtResourceFactory(resourceProvider));

		// ... and for anything that is referenced with an "ea:/" protocol.
		resourceSet.getResourceFactoryRegistry().getProtocolToFactoryMap().put("ea",
				new Eastadl22ResourceFactoryImpl());

		// We are now getting an instance of the correct resource implementation here
		Resource resource = resourceSet.getResource(fileUri, true);

		try {
			if (resource.getContents() == null || resource.getContents().isEmpty()) {
				resource.load(null);
			}
		} catch (IOException e) {
			logger.warn("File " + fileUri.toString() + " could not be loaded.", e);
			return null;
		}

		if (resource.getContents() == null || resource.getContents().isEmpty()) {
			logger.info("File " + fileUri.toString() + " did not contain any contents");
		}

		return resource.getContents().get(0);
	}

	class Visitor implements IResourceVisitor {

		private List<String> exclusionList = Arrays.asList(new String[] { "bin", "target" });

		private List<URI> fileUris = new ArrayList<>();

		private List<String> extensions;

		public Visitor(List<String> extensions) {
			if (extensions == null) {
				throw new IllegalArgumentException("Extensions cannot be null");
			}
			this.extensions = extensions;
		}

		public boolean visit(IResource resource) {
			if (resource.exists() && (resource.isHidden() || !resource.isAccessible())) {
				return false;
			}
			if (exclusionList.contains(resource.getName())) {
				return false;
			}

			if (resource != null && resource.getType() == IResource.FILE
					&& this.extensions.contains(resource.getFileExtension()))
				fileUris.add(URI.createPlatformResourceURI(resource.getFullPath().toOSString(), true));
			return true;
		}

		public List<URI> getFileUris() {
			return this.fileUris;
		}
	}

	/**
	 * Retrieves all files with the given {@code extensions} in the workspace.
	 * 
	 * @param extensions the extensions of the files of interest
	 * @return a list of platform URIs for the files with the given extension in the
	 *         workspace
	 */
	private List<URI> getAllFilesInWorkspace(List<String> extensions) {
		if (extensions == null) {
			throw new IllegalArgumentException("Extensions cannot be null");
		}
		Visitor visitor = new Visitor(extensions);

		try {
			ResourcesPlugin.getWorkspace().getRoot().accept(visitor);
		} catch (CoreException e) {
			logger.warn("Could not visit all resources", e);
		}

		return visitor.getFileUris();
	}

}
